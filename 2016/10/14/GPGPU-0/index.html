<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="GPU," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Entry FunctionThe entry function in the gpgpu-sim is __cudaRegisterFatBinary(). This function first calls CUctx_st &amp;lowast;context = GPGPUSim_Context(), which calls GPGPUSim_Init().123456789static CUc">
<meta property="og:type" content="article">
<meta property="og:title" content="GPGPU-sim code reading notes">
<meta property="og:url" content="http://61f.tech/2016/10/14/GPGPU-0/index.html">
<meta property="og:site_name" content="Kover's loft">
<meta property="og:description" content="Entry FunctionThe entry function in the gpgpu-sim is __cudaRegisterFatBinary(). This function first calls CUctx_st &amp;lowast;context = GPGPUSim_Context(), which calls GPGPUSim_Init().123456789static CUc">
<meta property="og:image" content="http://gpgpu-sim.org/manual/images/0/0e/Mempart-arch.png">
<meta property="og:updated_time" content="2016-10-14T09:11:05.842Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GPGPU-sim code reading notes">
<meta name="twitter:description" content="Entry FunctionThe entry function in the gpgpu-sim is __cudaRegisterFatBinary(). This function first calls CUctx_st &amp;lowast;context = GPGPUSim_Context(), which calls GPGPUSim_Init().123456789static CUc">
<meta name="twitter:image" content="http://gpgpu-sim.org/manual/images/0/0e/Mempart-arch.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://61f.tech/2016/10/14/GPGPU-0/"/>





  <title>GPGPU-sim code reading notes | Kover's loft</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kover's loft</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://61f.tech/2016/10/14/GPGPU-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kover">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kover's loft">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GPGPU-sim code reading notes</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-14T09:00:00+08:00">
                2016-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ParallelComputing/" itemprop="url" rel="index">
                    <span itemprop="name">ParallelComputing</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Entry-Function"><a href="#Entry-Function" class="headerlink" title="Entry Function"></a>Entry Function</h2><p>The entry function in the gpgpu-sim is <strong><em>__cudaRegisterFatBinary()</em></strong>. This function first calls <strong><em>CUctx_st &lowast;context = GPGPUSim_Context()</em></strong>, which calls <strong><em>GPGPUSim_Init()</em></strong>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> CUctx_st* <span class="title">GPGPUSim_Context</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">static</span> CUctx_st *the_context = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span>( the_context == <span class="literal">NULL</span> ) &#123;</div><div class="line">                <span class="number">_</span>cuda_device_id *the_gpu = GPGPUSim_Init();</div><div class="line">                the_context = <span class="keyword">new</span> CUctx_st(the_gpu);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> the_context;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note that <strong><em>the_context</em></strong> is static thus there is only one copy of it and the context creation(<strong><em>new CUctx_st(the_gpu)</em></strong>) and <strong><em>GPGPUSim_Init()</em></strong> are only executed once, no matter how many kernels are launched.<br>The most important member in the <strong><em>_cuda_device_id</em></strong> struct is the class <strong><em>gpgpu_sim &lowast;m_gpgpu</em></strong>. <strong><em>gpgpu_sim</em></strong> defines all important interfaces that <strong><em>GPGPU_SIM</em></strong> provides, such as gpu configuration, statistics collection, simulation control, etc. We can find that <strong><em>GPGPUSim_Init()</em></strong> invokes <strong><em>gpgpu_ptx_sim_init_perf()</em></strong>, which creates and returns a new <strong><em>gpgpu_sim</em></strong> object by calling <strong><em>option_paser_cmdline()</em></strong> to parse the input <strong><em>gpgpusim.config</em></strong> file. The function <strong><em>option_paser_cmdline()</em></strong> futher calls several other functions such as <strong><em>ParseCommandLine()</em></strong> and <strong><em>ParseFile()</em></strong> to do the actual config file parsing.<br>Other than creating a <strong><em>gpgpu_sim</em></strong> object and a corresponding <strong><em>_cuda_device_id</em></strong> from the configuration file, <strong><em>GPGPUSim_Init()</em></strong> also calls the <strong><em>start_sim_thread(1)</em></strong> function:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_sim_thread</span><span class="params">(<span class="keyword">int</span> api)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( g_sim_done ) &#123;</div><div class="line">        g_sim_done = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>( api == <span class="number">1</span> ) &#123;</div><div class="line">           pthread_create(&amp;g_simulation_thread,<span class="literal">NULL</span>,gpgpu_sim_thread_concurrent,<span class="literal">NULL</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">           pthread_create(&amp;g_simulation_thread,<span class="literal">NULL</span>,gpgpu_sim_thread_sequential,<span class="literal">NULL</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Obviously, <strong><em>start_sim_thread(1)</em></strong> will fork a thread to execute the <strong><em>gpgpu_sim_thread_concurrent()</em></strong> function:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">gpgpu_sim_thread_concurrent</span><span class="params">(<span class="keyword">void</span>*)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// concurrent kernel execution simulation thread</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">          <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: *** simulation thread starting and spinning waiting for work ***\n"</span>);</div><div class="line">          fflush(<span class="built_in">stdout</span>);</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">while</span>( g_stream_manager-&gt;empty_protected() &amp;&amp; !g_sim_done )</div><div class="line">            ;</div><div class="line">        <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: ** START simulation thread (detected work) **\n"</span>);</div><div class="line">           g_stream_manager-&gt;print(<span class="built_in">stdout</span>);</div><div class="line">           fflush(<span class="built_in">stdout</span>);</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_lock(&amp;g_sim_lock);</div><div class="line">        g_sim_active = <span class="literal">true</span>;</div><div class="line">        pthread_mutex_unlock(&amp;g_sim_lock);</div><div class="line">        <span class="keyword">bool</span> active = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">bool</span> sim_cycles = <span class="literal">false</span>;</div><div class="line">        g_the_gpu-&gt;init();</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// check if a kernel has completed</span></div><div class="line">            <span class="comment">// launch operation on device if one is pending and can be run</span></div><div class="line"></div><div class="line">            <span class="comment">// Need to break this loop when a kernel completes. This was a</span></div><div class="line">            <span class="comment">// source of non-deterministic behaviour in GPGPU-Sim (bug 147).</span></div><div class="line">            <span class="comment">// If another stream operation is available, g_the_gpu remains active,</span></div><div class="line">            <span class="comment">// causing this loop to not break. If the next operation happens to be</span></div><div class="line">            <span class="comment">// another kernel, the gpu is not re-initialized and the inter-kernel</span></div><div class="line">            <span class="comment">// behaviour may be incorrect. Check that a kernel has finished and</span></div><div class="line">            <span class="comment">// no other kernel is currently running.</span></div><div class="line">            <span class="keyword">if</span>(g_stream_manager-&gt;operation(&amp;sim_cycles) &amp;&amp; !g_the_gpu-&gt;active())</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>( g_the_gpu-&gt;active() ) &#123;</div><div class="line">                g_the_gpu-&gt;cycle();</div><div class="line">                sim_cycles = <span class="literal">true</span>;</div><div class="line">                g_the_gpu-&gt;deadlock_check();</div><div class="line">            &#125;</div><div class="line">            active=g_the_gpu-&gt;active() || !g_stream_manager-&gt;empty_protected();</div><div class="line">        &#125; <span class="keyword">while</span>( active );</div><div class="line">        <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: ** STOP simulation thread (no work) **\n"</span>);</div><div class="line">           fflush(<span class="built_in">stdout</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sim_cycles) &#123;</div><div class="line">            g_the_gpu-&gt;update_stats();</div><div class="line">            print_simulation_time();</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_lock(&amp;g_sim_lock);</div><div class="line">        g_sim_active = <span class="literal">false</span>;</div><div class="line">        pthread_mutex_unlock(&amp;g_sim_lock);</div><div class="line">    &#125; <span class="keyword">while</span>( !g_sim_done );</div><div class="line">    <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">       <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: *** simulation thread exiting ***\n"</span>);</div><div class="line">       fflush(<span class="built_in">stdout</span>);</div><div class="line">    &#125;</div><div class="line">    sem_post(&amp;g_sim_signal_exit);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note that <strong><em>g_the_gpu</em></strong> is a global variable defined in <strong><em>gpgpusim_entrypoint.cc</em></strong> and is initialized to point to the newly created <strong><em>gpgpu_sim</em></strong> object in <strong><em>gpgpu_ptx_sim_init_perf()</em></strong> .<br>The effect of executing <strong><em>g_the_gpu-&gt;init()</em></strong> is to initialize simulation cycle, control flow, memory access, statistics of various kinds (simulation results), etc.<br>Following the init the simulation gets into a <strong><em>do…while</em></strong> loop.  This is the main loop that simulates the running cuda application cycle by cycle. Each iteration of this loop simulates one cycle (by <strong><em>g_stream_manager-&gt;operation(&amp;sim_cycles)</em></strong> and <strong><em>g_the_gpu-&gt;cycle()</em></strong>) if the <strong><em>g_the_gpu</em></strong> is active.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> stream_manager::operation( <span class="keyword">bool</span> * sim)</div><div class="line">&#123;</div><div class="line">        pthread_mutex_lock(&amp;m_lock);</div><div class="line">        <span class="keyword">bool</span> check=check_finished_kernel();</div><div class="line">        <span class="keyword">if</span>(check) m_gpu-&gt;print_stats();</div><div class="line">        stream_operation op =front();</div><div class="line">        op.do_operation( m_gpu );</div><div class="line">        pthread_mutex_unlock(&amp;m_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><em>stream_manager</em></strong> primarily contains a list of <strong><em>CUstream_st</em></strong> (<strong><em>m_streams</em></strong>), a pointer (<strong><em>m_gpu</em></strong>) to the simulation instance (<strong><em>gpgpu_sim</em></strong>), and some flags such as if the cuda launch is blocking or not.  The CUstream_st  is a struct that contains a list of <strong><em>stream_operation</em></strong> objects (<strong><em>std::list<stream_operation> m_operations</stream_operation></em></strong>) and a few methods to manipulate the <strong><em>stream_operation</em></strong> objects in the list.<br><strong><em>stream_operation</em></strong> essentially keeps track of different types of cuda operations such as kernel launch, memory copy, etc.<br>After <strong><em>stream_operation op</em></strong>  is popped from the list using <strong><em>front()</em></strong>, the statement <strong><em>op.do_operation(m_gpu)</em></strong> is executed.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> stream_operation::do_operation( gpgpu_sim *gpu )</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">switch</span>( m_type ) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">case</span> stream_kernel_launch:</div><div class="line">        <span class="keyword">if</span>( gpu-&gt;can_start_kernel() ) &#123;</div><div class="line">        	gpu-&gt;set_cache_config(m_kernel-&gt;name());</div><div class="line">        	<span class="built_in">printf</span>(<span class="string">"kernel \'%s\' transfer to GPU hardware scheduler\n"</span>, m_kernel-&gt;name().c_str() );</div><div class="line">            <span class="keyword">if</span>( m_sim_mode )</div><div class="line">                gpgpu_cuda_ptx_sim_main_func( *m_kernel );</div><div class="line">            <span class="keyword">else</span></div><div class="line">                gpu-&gt;launch( m_kernel );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">abort</span>();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This function contains a big switch case statement and gets to different branches based on the type of the stream operation. Since we mainly concern about the kernal launch thus we focus on <strong><em>stram_kernal_launch</em></strong> case. Based on which mode(performance simulation mode or purely functional simulation mode) is chosen, there are two paths.<br>We focus on tracing the code for performance simulation, so the second path, <strong><em>gpu-&gt;launch(m_kernel)</em></strong>, is executed. It puts <strong><em>m_kernel</em></strong><br>into a “NULL” or “done” element in the <strong><em>std::vector&lt;kernel_info_t</em>&gt; m_running_kernels*</strong> member in the <strong><em>gpgpu_sim</em></strong> instance. Importantly, putting valid things in the running kernel vector will result in a TRUE return value upon the <strong><em>bool gpgpu_sim::actvie()</em></strong> function invovation.<br>Thus <strong><em>g_the_gpu-&gt;cycle()</em></strong> will be executed for performance simulation after <strong><em>g_stream_manager-&gt;operation(&amp;sim_cycles)</em></strong> when performance simulated mode is selected.</p>
<h2 id="Simulating-One-Cycle-in-Performance-Simmulation"><a href="#Simulating-One-Cycle-in-Performance-Simmulation" class="headerlink" title="Simulating One Cycle in Performance Simmulation"></a>Simulating One Cycle in Performance Simmulation</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> gpgpu_sim::cycle()</div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> clock_mask = next_clock_domain();</div><div class="line">   <span class="comment">//=====1st part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; CORE ) &#123;</div><div class="line">       <span class="comment">// shader core loading (pop from ICNT into core) follows CORE clock</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) </div><div class="line">         m_cluster[i]-&gt;icnt_cycle(); </div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====1st part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====2nd part=====</span></div><div class="line">    <span class="keyword">if</span> (clock_mask &amp; ICNT) &#123;</div><div class="line">        <span class="comment">// pop from memory controller to interconnect</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem_sub_partition;i++) &#123;</div><div class="line">            mem_fetch* mf = m_memory_sub_partition[i]-&gt;top();</div><div class="line">            <span class="keyword">if</span> (mf) &#123;</div><div class="line">                <span class="keyword">unsigned</span> response_size = mf-&gt;get_is_write()?mf-&gt;get_ctrl_size():mf-&gt;size();</div><div class="line">                <span class="keyword">if</span> ( ::icnt_has_buffer( m_shader_config-&gt;mem2device(i), response_size ) ) &#123;</div><div class="line">                    <span class="keyword">if</span> (!mf-&gt;get_is_write()) </div><div class="line">                       mf-&gt;set_return_timestamp(gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">                    mf-&gt;set_status(IN_ICNT_TO_SHADER,gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">                    ::icnt_push( m_shader_config-&gt;mem2device(i), mf-&gt;get_tpc(), mf, response_size );</div><div class="line">                    m_memory_sub_partition[i]-&gt;pop();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    gpu_stall_icnt2sh++;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               m_memory_sub_partition[i]-&gt;pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//=====2nd part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====3rd part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; DRAM) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem;i++)&#123;</div><div class="line">         m_memory_partition_unit[i]-&gt;dram_cycle(); <span class="comment">// Issue the dram command (scheduler + delay model)</span></div><div class="line">         <span class="comment">// Update performance counters for DRAM</span></div><div class="line">         m_memory_partition_unit[i]-&gt;set_dram_power_stats(m_power_stats-&gt;pwr_mem_stat-&gt;n_cmd[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_activity[CURRENT_STAT_IDX][i],</div><div class="line">                        m_power_stats-&gt;pwr_mem_stat-&gt;n_nop[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_act[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_pre[CURRENT_STAT_IDX][i],</div><div class="line">                        m_power_stats-&gt;pwr_mem_stat-&gt;n_rd[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_wr[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_req[CURRENT_STAT_IDX][i]);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====3rd part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====4th part=====</span></div><div class="line">   <span class="comment">// L2 operations follow L2 clock domain</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; L2) &#123;</div><div class="line">       m_power_stats-&gt;pwr_mem_stat-&gt;l2_cache_stats[CURRENT_STAT_IDX].clear();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem_sub_partition;i++) &#123;</div><div class="line">          <span class="comment">//move memory request from interconnect into memory partition (if not backed up)</span></div><div class="line">          <span class="comment">//Note:This needs to be called in DRAM clock domain if there is no L2 cache in the system</span></div><div class="line">          <span class="keyword">if</span> ( m_memory_sub_partition[i]-&gt;full() ) &#123;</div><div class="line">             gpu_stall_dramfull++;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              mem_fetch* mf = (mem_fetch*) icnt_pop( m_shader_config-&gt;mem2device(i) );</div><div class="line">              m_memory_sub_partition[i]-&gt;push( mf, gpu_sim_cycle + gpu_tot_sim_cycle );</div><div class="line">          &#125;</div><div class="line">          m_memory_sub_partition[i]-&gt;cache_cycle(gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">          m_memory_sub_partition[i]-&gt;accumulate_L2cache_stats(m_power_stats-&gt;pwr_mem_stat-&gt;l2_cache_stats[CURRENT_STAT_IDX]);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====4th part end=====</span></div><div class="line"></div><div class="line">   <span class="comment">//=====5th part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; ICNT) &#123;</div><div class="line">      icnt_transfer();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====5th part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====6th part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; CORE) &#123;</div><div class="line">      <span class="comment">// L1 cache + shader core pipeline stages</span></div><div class="line">      m_power_stats-&gt;pwr_mem_stat-&gt;core_cache_stats[CURRENT_STAT_IDX].clear();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) &#123;</div><div class="line">         <span class="keyword">if</span> (m_cluster[i]-&gt;get_not_completed() || get_more_cta_left() ) &#123;</div><div class="line">               m_cluster[i]-&gt;core_cycle();</div><div class="line">               *active_sms+=m_cluster[i]-&gt;get_n_active_sms();</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// Update core icnt/cache stats for GPUWattch</span></div><div class="line">         m_cluster[i]-&gt;get_icnt_stats(m_power_stats-&gt;pwr_mem_stat-&gt;n_simt_to_mem[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_mem_to_simt[CURRENT_STAT_IDX][i]);</div><div class="line">         m_cluster[i]-&gt;get_cache_stats(m_power_stats-&gt;pwr_mem_stat-&gt;core_cache_stats[CURRENT_STAT_IDX]);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">float</span> temp=<span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;num_shader();i++)&#123;</div><div class="line">        temp+=m_shader_stats-&gt;m_pipeline_duty_cycle[i];</div><div class="line">      &#125;</div><div class="line">      temp=temp/m_shader_config-&gt;num_shader();</div><div class="line">      *average_pipeline_duty_cycle=((*average_pipeline_duty_cycle)+temp);</div><div class="line">        <span class="comment">//cout&lt;&lt;"Average pipeline duty cycle: "&lt;&lt;*average_pipeline_duty_cycle&lt;&lt;endl;</span></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">if</span>( g_single_step &amp;&amp; ((gpu_sim_cycle+gpu_tot_sim_cycle) &gt;= g_single_step) ) &#123;</div><div class="line">          <span class="keyword">asm</span>(<span class="string">"int $03"</span>);</div><div class="line">      &#125;</div><div class="line">      gpu_sim_cycle++;</div><div class="line">      <span class="keyword">if</span>( g_interactive_debugger_enabled ) </div><div class="line">         gpgpu_debug();</div><div class="line"></div><div class="line">      <span class="comment">// McPAT main cycle (interface with McPAT)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GPGPUSIM_POWER_MODEL</span></div><div class="line">      <span class="keyword">if</span>(m_config.g_power_simulation_enabled)&#123;</div><div class="line">          mcpat_cycle(m_config, getShaderCoreConfig(), m_gpgpusim_wrapper, m_power_stats, m_config.gpu_stat_sample_freq, gpu_tot_sim_cycle, gpu_sim_cycle, gpu_tot_sim_insn, gpu_sim_insn);</div><div class="line">      &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">   <span class="comment">//=====6th part end=====</span></div><div class="line">   </div><div class="line">      issue_block2core();</div><div class="line">      </div><div class="line">      <span class="comment">// Depending on configuration, flush the caches once all of threads are completed.</span></div><div class="line">      <span class="keyword">int</span> all_threads_complete = <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (m_config.gpgpu_flush_l1_cache) &#123;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (m_cluster[i]-&gt;get_not_completed() == <span class="number">0</span>)</div><div class="line">                m_cluster[i]-&gt;cache_flush();</div><div class="line">            <span class="keyword">else</span></div><div class="line">               all_threads_complete = <span class="number">0</span> ;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(m_config.gpgpu_flush_l2_cache)&#123;</div><div class="line">          <span class="keyword">if</span>(!m_config.gpgpu_flush_l1_cache)&#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) &#123;</div><div class="line">                  <span class="keyword">if</span> (m_cluster[i]-&gt;get_not_completed() != <span class="number">0</span>)&#123;</div><div class="line">                      all_threads_complete = <span class="number">0</span> ;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (all_threads_complete &amp;&amp; !m_memory_config-&gt;m_L2_config.disabled() ) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Flushed L2 caches...\n"</span>);</div><div class="line">            <span class="keyword">if</span> (m_memory_config-&gt;m_L2_config.get_num_lines()) &#123;</div><div class="line">               <span class="keyword">int</span> dlc = <span class="number">0</span>;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem;i++) &#123;</div><div class="line">                  dlc = m_memory_sub_partition[i]-&gt;flushL2();</div><div class="line">                  assert (dlc == <span class="number">0</span>); <span class="comment">// need to model actual writes to DRAM here</span></div><div class="line">                  <span class="built_in">printf</span>(<span class="string">"Dirty lines flushed from L2 %d is %d\n"</span>, i, dlc  );</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!(gpu_sim_cycle % m_config.gpu_stat_sample_freq)) &#123;</div><div class="line">         <span class="keyword">time_t</span> days, hrs, minutes, sec;</div><div class="line">         <span class="keyword">time_t</span> curr_time;</div><div class="line">         time(&amp;curr_time);</div><div class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  elapsed_time = MAX(curr_time - g_simulation_starttime, <span class="number">1</span>);</div><div class="line">         <span class="keyword">if</span> ( (elapsed_time - last_liveness_message_time) &gt;= m_config.liveness_message_freq ) &#123;</div><div class="line">            days    = elapsed_time/(<span class="number">3600</span>*<span class="number">24</span>);</div><div class="line">            hrs     = elapsed_time/<span class="number">3600</span> - <span class="number">24</span>*days;</div><div class="line">            minutes = elapsed_time/<span class="number">60</span> - <span class="number">60</span>*(hrs + <span class="number">24</span>*days);</div><div class="line">            sec = elapsed_time - <span class="number">60</span>*(minutes + <span class="number">60</span>*(hrs + <span class="number">24</span>*days));</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim uArch: cycles simulated: %lld  inst.: %lld (ipc=%4.1f) sim_rate=%u (inst/sec) elapsed = %u:%u:%02u:%02u / %s"</span>, </div><div class="line">                   gpu_tot_sim_cycle + gpu_sim_cycle, gpu_tot_sim_insn + gpu_sim_insn, </div><div class="line">                   (<span class="keyword">double</span>)gpu_sim_insn/(<span class="keyword">double</span>)gpu_sim_cycle,</div><div class="line">                   (<span class="keyword">unsigned</span>)((gpu_tot_sim_insn+gpu_sim_insn) / elapsed_time),</div><div class="line">                   (<span class="keyword">unsigned</span>)days,(<span class="keyword">unsigned</span>)hrs,(<span class="keyword">unsigned</span>)minutes,(<span class="keyword">unsigned</span>)sec,</div><div class="line">                   ctime(&amp;curr_time));</div><div class="line">            fflush(<span class="built_in">stdout</span>);</div><div class="line">            last_liveness_message_time = elapsed_time; </div><div class="line">         &#125;</div><div class="line">         visualizer_printstat();</div><div class="line">         m_memory_stats-&gt;memlatstat_lat_pw();</div><div class="line">         <span class="keyword">if</span> (m_config.gpgpu_runtime_stat &amp;&amp; (m_config.gpu_runtime_stat_flag != <span class="number">0</span>) ) &#123;</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_BW_STAT) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem;i++) </div><div class="line">                  m_memory_partition_unit[i]-&gt;print_stat(<span class="built_in">stdout</span>);</div><div class="line">               <span class="built_in">printf</span>(<span class="string">"maxmrqlatency = %d \n"</span>, m_memory_stats-&gt;max_mrq_latency);</div><div class="line">               <span class="built_in">printf</span>(<span class="string">"maxmflatency = %d \n"</span>, m_memory_stats-&gt;max_mf_latency);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_SHD_INFO) </div><div class="line">               shader_print_runtime_stat( <span class="built_in">stdout</span> );</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_L1MISS) </div><div class="line">               shader_print_l1_miss_stat( <span class="built_in">stdout</span> );</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_SCHED) </div><div class="line">               shader_print_scheduler_stat( <span class="built_in">stdout</span>, <span class="literal">false</span> );</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!(gpu_sim_cycle % <span class="number">20000</span>)) &#123;</div><div class="line">         <span class="comment">// deadlock detection </span></div><div class="line">         <span class="keyword">if</span> (m_config.gpu_deadlock_detect &amp;&amp; gpu_sim_insn == last_gpu_sim_insn) &#123;</div><div class="line">            gpu_deadlock = <span class="literal">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            last_gpu_sim_insn = gpu_sim_insn;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      try_snap_shot(gpu_sim_cycle);</div><div class="line">      spill_log_to_file (<span class="built_in">stdout</span>, <span class="number">0</span>, gpu_sim_cycle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="simt-core-cluster"><a href="#simt-core-cluster" class="headerlink" title="simt_core_cluster"></a>simt_core_cluster</h3><p>Class <strong><em>simt_core_cluster</em></strong> models the SIMT core clusters. This class contains an array of SIMT core objects(the member <strong><em>shader_core_ctx &lowast;&lowast;m_core</em></strong>).<br>The <strong><em>simt_core_cluster::core_cycle()</em></strong> method simply cycles each of the SIMT core in order.<br>The <strong><em>simt_core_cluster::icnt_cycle()</em></strong> method pushes memory requests into the SIMT Core Cluster’s reponse FIFO (the member <strong><em>std::list<mem_fetch> m_response_fifo</mem_fetch></em></strong> in the <strong><em>simt_core_cluster</em></strong> class) from the interconnection network. It also pops the requests from the FIFO and sends them to the appropriate core’s instruction cache(the member <strong><em>read_only_cache &lowast;m_L1</em></strong> in the <strong><em>shader_core_ctx</em></strong>) or LDST unit(the member <strong><em>ldst_unit &lowast;m_ldst_unit</em></strong> in the <strong><em>shader_core_ctx</em></strong>).</p>
<h3 id="core-t"><a href="#core-t" class="headerlink" title="core_t"></a>core_t</h3><p>The <strong><em>core_t</em></strong> class just provides an abstract base class for <strong><em>shader_core_ctx</em></strong>  to inherit. <strong><em>core_t</em></strong> contains basic information such as the kernel information (the member <strong><em>kernel_info_t &lowast;m_kernel</em></strong>), ptx thread information (the member class <strong><em>ptx_thread_info &lowast;&lowast; m_thread</em></strong>), SIMT stack (the member <strong><em>simt_stack  &lowast;&lowast;m_simt_stack</em></strong>) and the current simulation instance (the member <strong><em>gpgpu_sim &lowast;m_gpu</em></strong>).  </p>
<h3 id="shader-core-ctx"><a href="#shader-core-ctx" class="headerlink" title="shader_core_ctx"></a>shader_core_ctx</h3><p>Class <strong><em>shader_core_ctx</em></strong> models the SIMT core. Other than the <strong><em>read_only_cache &lowast;m_L1</em></strong> and <strong><em>ldst_unit &lowast;m_ldst_unit</em></strong> members, the class <strong><em>shader_core_ctx</em></strong> also has other important compoents such as the registers for communication between two pipeline stages(e.g. the member <strong><em>std::vector<register_set> m_pipeline_reg</register_set></em></strong>), the scoreboard(the member <strong><em>Scoreboard &lowast;m_scoreboard</em></strong>), the scheduler(the member <strong><em>std::vector&lt;scheduler_unit</em>&gt; schedulers*</strong>) and the operand collector(the member <strong><em>opndcoll_rfu_t m_operand_collector</em></strong>).  </p>
<h3 id="ldst-unit"><a href="#ldst-unit" class="headerlink" title="ldst_unit"></a>ldst_unit</h3><p>Class <strong><em>ldst_unit</em></strong>,a member in the <strong><em>shader_core_ctx</em></strong>  class, contains various memory related components of a shader core including texture caches, constant caches, data caches.<br>Both the <strong><em>simt_core_cluster</em></strong> and the <strong><em>ldst_unit</em></strong> class (a shader core’s load store unit) defines a member named <strong><em>m_response_fifo</em></strong>, which is actually a list of <strong><em>mem_fetch</em></strong> pointers.<br>Class <strong><em>mem_fetch</em></strong> abstracts memory fetch operations with various relevant information such as the memory access type, source, destination, current status, fetched instruction (if it’s an instruction access), etc. In particular, it has members <strong><em>warp_inst_t m_inst</em></strong> and  <strong><em>mem_access_t m_access</em></strong>.<br>Class <strong><em>mem_access_t</em></strong> class just includes simple members related to a memory access such as the address, write or read, requested size, access type and active mask.<br>Class <strong><em>warp_inst_t</em></strong>  class represents an instruction in a warp and comprises information such as the memory accesses incurred by the instruction (the member <strong><em>std::list<mem_access_t> m_accessq</mem_access_t></em></strong>), active mask(<strong><em>active_mask_t m_warp_active_mask</em></strong>), if atomic, cycle when it’s issued, etc.<br>Class <strong><em>warp_inst_t</em></strong> inherits the class <strong><em>inst_t</em></strong> , which defines basic instruction information such as the opcode (the member <strong><em>op_type op</em></strong>), if load or store, register usage, latency (the member <strong><em>unsigned latency</em></strong>), etc.</p>
<h3 id="1st-part-Pushing-memory-request-into-FIFO-and-filling-the-L1-cache"><a href="#1st-part-Pushing-memory-request-into-FIFO-and-filling-the-L1-cache" class="headerlink" title="1st part - Pushing memory request into FIFO and filling the L1 cache"></a>1st part - Pushing memory request into FIFO and filling the L1 cache</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> simt_core_cluster::icnt_cycle()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( !m_response_fifo.empty() ) &#123;</div><div class="line">        mem_fetch *mf = m_response_fifo.front();</div><div class="line">        <span class="keyword">unsigned</span> cid = m_config-&gt;sid_to_cid(mf-&gt;get_sid());</div><div class="line">        <span class="keyword">if</span>( mf-&gt;get_access_type() == INST_ACC_R ) &#123;</div><div class="line">            <span class="comment">// instruction fetch response</span></div><div class="line">            <span class="keyword">if</span>( !m_core[cid]-&gt;fetch_unit_response_buffer_full() ) &#123;</div><div class="line">                m_response_fifo.pop_front();</div><div class="line">                m_core[cid]-&gt;accept_fetch_response(mf);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// data response</span></div><div class="line">            <span class="keyword">if</span>( !m_core[cid]-&gt;ldst_unit_response_buffer_full() ) &#123;</div><div class="line">                m_response_fifo.pop_front();</div><div class="line">                m_memory_stats-&gt;memlatstat_read_done(mf);</div><div class="line">                m_core[cid]-&gt;accept_ldst_unit_response(mf);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( m_response_fifo.size() &lt; m_config-&gt;n_simt_ejection_buffer_size ) &#123;</div><div class="line">        mem_fetch *mf = (mem_fetch*) ::icnt_pop(m_cluster_id);</div><div class="line">        <span class="keyword">if</span> (!mf) </div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        assert(mf-&gt;get_tpc() == m_cluster_id);</div><div class="line">        assert(mf-&gt;get_type() == READ_REPLY || mf-&gt;get_type() == WRITE_ACK );</div><div class="line"></div><div class="line">        <span class="comment">// The packet size varies depending on the type of request: </span></div><div class="line">        <span class="comment">// - For read request and atomic request, the packet contains the data </span></div><div class="line">        <span class="comment">// - For write-ack, the packet only has control metadata</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size = (mf-&gt;get_is_write())? mf-&gt;get_ctrl_size() : mf-&gt;size(); </div><div class="line">        m_stats-&gt;m_incoming_traffic_stats-&gt;record_traffic(mf, packet_size); </div><div class="line">        mf-&gt;set_status(IN_CLUSTER_TO_SHADER_QUEUE,gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">        <span class="comment">//m_memory_stats-&gt;memlatstat_read_done(mf,m_shader_config-&gt;max_warps_per_shader);</span></div><div class="line">        m_response_fifo.push_back(mf);</div><div class="line">        m_stats-&gt;n_mem_to_simt[m_cluster_id] += mf-&gt;get_num_flits(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If <strong><em>m_response_fifo</em></strong> is not empty, <strong><em>mem_fetch</em></strong> is retrieved from the front of the <strong><em>m_response_fifo</em></strong> and <strong><em>mf</em></strong>‘s type is checked. If it’s an instruction access execute <strong><em>m_core[cid]-&gt;accept_fetch_response(mf)</em></strong> to fill the shader’s L1 instruction cache, otherwise do <strong><em>m_core[cid]-&gt;accept_ldst_unit_response(mf)</em></strong> to fill the ldst unit.<br>If <strong><em>m_response_fifo</em></strong> is not full, a <strong><em>mem_fetch</em></strong> poped from the interconnection network will be pushed into the FIFO.</p>
<h3 id="2nd-part-Popping-from-Memory-Controller-to-NoC"><a href="#2nd-part-Popping-from-Memory-Controller-to-NoC" class="headerlink" title="2nd part - Popping from Memory Controller to NoC"></a>2nd part - Popping from Memory Controller to NoC</h3><p><strong><em>class memory_sub_partition &lowast;&lowast;m_memory_sub_partition</em></strong> is a member of the <strong><em>gpgpu_sim</em></strong> class.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> memory_sub_partition</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   memory_sub_partition( <span class="keyword">unsigned</span> sub_partition_id, <span class="keyword">const</span> <span class="keyword">struct</span> memory_config *config, <span class="keyword">class</span> <span class="keyword">memory_stats_t</span> *stats );</div><div class="line">   ~memory_sub_partition(); </div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">unsigned</span> <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125; </div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">busy</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">cache_cycle</span><span class="params">( <span class="keyword">unsigned</span> cycle )</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">( <span class="keyword">class</span> mem_fetch* mf, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> clock_cycle )</span></span>;</div><div class="line">   <span class="function"><span class="keyword">class</span> mem_fetch* <span class="title">pop</span><span class="params">()</span></span>; </div><div class="line">   <span class="function"><span class="keyword">class</span> mem_fetch* <span class="title">top</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set_done</span><span class="params">( mem_fetch *mf )</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">unsigned</span> <span class="title">flushL2</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">// interface to L2_dram_queue</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">L2_dram_queue_empty</span><span class="params">()</span> <span class="keyword">const</span></span>; </div><div class="line">   <span class="function"><span class="keyword">class</span> mem_fetch* <span class="title">L2_dram_queue_top</span><span class="params">()</span> <span class="keyword">const</span></span>; </div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">L2_dram_queue_pop</span><span class="params">()</span></span>; </div><div class="line"></div><div class="line">   <span class="comment">// interface to dram_L2_queue</span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">dram_L2_queue_full</span><span class="params">()</span> <span class="keyword">const</span></span>; </div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dram_L2_queue_push</span><span class="params">( <span class="keyword">class</span> mem_fetch* mf )</span></span>; </div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">visualizer_print</span><span class="params">( gzFile visualizer_file )</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print_cache_stat</span><span class="params">(<span class="keyword">unsigned</span> &amp;accesses, <span class="keyword">unsigned</span> &amp;misses)</span> <span class="keyword">const</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( FILE *fp )</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">accumulate_L2cache_stats</span><span class="params">(<span class="keyword">class</span> cache_stats &amp;l2_stats)</span> <span class="keyword">const</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">get_L2cache_sub_stats</span><span class="params">(<span class="keyword">struct</span> cache_sub_stats &amp;css)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"><span class="comment">// data</span></div><div class="line">   <span class="keyword">unsigned</span> m_id;  <span class="comment">//&lt; the global sub partition ID</span></div><div class="line">   <span class="keyword">const</span> <span class="keyword">struct</span> memory_config *m_config;</div><div class="line">   <span class="keyword">class</span> l2_cache *m_L2cache;</div><div class="line">   <span class="keyword">class</span> L2interface *m_L2interface;</div><div class="line">   partition_mf_allocator *m_mf_allocator;</div><div class="line"></div><div class="line">   <span class="comment">// model delay of ROP units with a fixed latency</span></div><div class="line">   <span class="keyword">struct</span> <span class="keyword">rop_delay_t</span></div><div class="line">   &#123;</div><div class="line">    	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ready_cycle;</div><div class="line">    	<span class="keyword">class</span> mem_fetch* req;</div><div class="line">   &#125;;</div><div class="line">   <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">rop_delay_t</span>&gt; m_rop;</div><div class="line"></div><div class="line">   <span class="comment">// these are various FIFOs between units within a memory partition</span></div><div class="line">   fifo_pipeline&lt;mem_fetch&gt; *m_icnt_L2_queue;</div><div class="line">   fifo_pipeline&lt;mem_fetch&gt; *m_L2_dram_queue;</div><div class="line">   fifo_pipeline&lt;mem_fetch&gt; *m_dram_L2_queue;</div><div class="line">   fifo_pipeline&lt;mem_fetch&gt; *m_L2_icnt_queue; <span class="comment">// L2 cache hit response queue</span></div><div class="line"></div><div class="line">   <span class="keyword">class</span> mem_fetch *L2dramout; </div><div class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> wb_addr;</div><div class="line"></div><div class="line">   <span class="keyword">class</span> <span class="keyword">memory_stats_t</span> *m_stats;</div><div class="line"></div><div class="line">   <span class="built_in">std</span>::<span class="built_in">set</span>&lt;mem_fetch*&gt; m_request_tracker;</div><div class="line"></div><div class="line">   <span class="keyword">friend</span> <span class="keyword">class</span> L2interface;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>This structure is describing the model mentioned in the official document.<br><img src="http://gpgpu-sim.org/manual/images/0/0e/Mempart-arch.png" alt=""><br>The code segment<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">::icnt_push( m_shader_config-&gt;mem2device(i), mf-&gt;get_tpc(), mf, response_size );</div><div class="line">m_memory_sub_partition[i]-&gt;pop();</div></pre></td></tr></table></figure></p>
<p>injects memory requests into the interconnect from the Memory Partition’s L2-&gt;icnt queue.</p>
<h3 id="3rd-part-One-cycle-in-DRAM"><a href="#3rd-part-One-cycle-in-DRAM" class="headerlink" title="3rd part - One cycle in DRAM"></a>3rd part - One cycle in DRAM</h3><p><strong><em>class memory_partition_unit &lowast;&lowast;m_memory_partition_unit</em></strong> is a member of the <strong><em>gpgpu_sim</em></strong> class.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Memory partition unit contains all the units assolcated with a single DRAM channel. </span></div><div class="line"><span class="comment">// - It arbitrates the DRAM channel among multiple sub partitions.  </span></div><div class="line"><span class="comment">// - It does not connect directly with the interconnection network. </span></div><div class="line"><span class="keyword">class</span> memory_partition_unit</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>: </div><div class="line">   memory_partition_unit( <span class="keyword">unsigned</span> partition_id, <span class="keyword">const</span> <span class="keyword">struct</span> memory_config *config, <span class="keyword">class</span> <span class="keyword">memory_stats_t</span> *stats );</div><div class="line">   ~memory_partition_unit(); </div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">busy</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">cache_cycle</span><span class="params">( <span class="keyword">unsigned</span> cycle )</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dram_cycle</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set_done</span><span class="params">( mem_fetch *mf )</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">visualizer_print</span><span class="params">( gzFile visualizer_file )</span> <span class="keyword">const</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print_stat</span><span class="params">( FILE *fp )</span> </span>&#123; m_dram-&gt;print_stat(fp); &#125;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">visualize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; m_dram-&gt;visualize(); &#125;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( FILE *fp )</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">class</span> memory_sub_partition * <span class="title">get_sub_partition</span><span class="params">(<span class="keyword">int</span> sub_partition_id)</span> </span></div><div class="line">   &#123;</div><div class="line">      <span class="keyword">return</span> m_sub_partition[sub_partition_id]; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Power model</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set_dram_power_stats</span><span class="params">(<span class="keyword">unsigned</span> &amp;n_cmd,</span></span></div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_activity,</div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_nop,</div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_act,</div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_pre,</div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_rd,</div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_wr,</div><div class="line">                             <span class="keyword">unsigned</span> &amp;n_req) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">global_sub_partition_id_to_local_id</span><span class="params">(<span class="keyword">int</span> global_sub_partition_id)</span> <span class="keyword">const</span></span>; </div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">unsigned</span> <span class="title">get_mpid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line"></div><div class="line">   <span class="keyword">unsigned</span> m_id;</div><div class="line">   <span class="keyword">const</span> <span class="keyword">struct</span> memory_config *m_config;</div><div class="line">   <span class="keyword">class</span> <span class="keyword">memory_stats_t</span> *m_stats;</div><div class="line">   <span class="keyword">class</span> memory_sub_partition **m_sub_partition; </div><div class="line">   <span class="keyword">class</span> <span class="keyword">dram_t</span> *m_dram;</div><div class="line"></div><div class="line">   <span class="keyword">class</span> arbitration_metadata</div><div class="line">   &#123;</div><div class="line">   <span class="keyword">public</span>: </div><div class="line">      arbitration_metadata(<span class="keyword">const</span> <span class="keyword">struct</span> memory_config *config); </div><div class="line"></div><div class="line">      <span class="comment">// check if a subpartition still has credit </span></div><div class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">has_credits</span><span class="params">(<span class="keyword">int</span> inner_sub_partition_id)</span> <span class="keyword">const</span></span>; </div><div class="line">      <span class="comment">// borrow a credit for a subpartition </span></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">borrow_credit</span><span class="params">(<span class="keyword">int</span> inner_sub_partition_id)</span></span>; </div><div class="line">      <span class="comment">// return a credit from a subpartition </span></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">return_credit</span><span class="params">(<span class="keyword">int</span> inner_sub_partition_id)</span></span>; </div><div class="line"></div><div class="line">      <span class="comment">// return the last subpartition that borrowed credit </span></div><div class="line">      <span class="function"><span class="keyword">int</span> <span class="title">last_borrower</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_last_borrower; &#125; </div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( FILE *fp )</span> <span class="keyword">const</span></span>; </div><div class="line">   <span class="keyword">private</span>: </div><div class="line">      <span class="comment">// id of the last subpartition that borrowed credit </span></div><div class="line">      <span class="keyword">int</span> m_last_borrower; </div><div class="line"></div><div class="line">      <span class="keyword">int</span> m_shared_credit_limit; </div><div class="line">      <span class="keyword">int</span> m_private_credit_limit; </div><div class="line"></div><div class="line">      <span class="comment">// credits borrowed by the subpartitions</span></div><div class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m_private_credit; </div><div class="line">      <span class="keyword">int</span> m_shared_credit; </div><div class="line">   &#125;; </div><div class="line">   arbitration_metadata m_arbitration_metadata; </div><div class="line"></div><div class="line">   <span class="comment">// determine wheither a given subpartition can issue to DRAM </span></div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">can_issue_to_dram</span><span class="params">(<span class="keyword">int</span> inner_sub_partition_id)</span></span>; </div><div class="line"></div><div class="line">   <span class="comment">// model DRAM access scheduler latency (fixed latency between L2 and DRAM)</span></div><div class="line">   <span class="keyword">struct</span> <span class="keyword">dram_delay_t</span></div><div class="line">   &#123;</div><div class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ready_cycle;</div><div class="line">      <span class="keyword">class</span> mem_fetch* req;</div><div class="line">   &#125;;</div><div class="line">   <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">dram_delay_t</span>&gt; m_dram_latency_queue;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>The <strong>DRAM latency</strong> queue is a fixed latency queue that models the minimum latency difference between a L2 access and a DRAM access. A <strong>DRAM latency</strong> queue can receive memory request from multiple <strong>L2-&gt;DRAM</strong> queues.<br>Requests exiting the <strong>L2-&gt;DRAM</strong> queue reside in the <strong>DRAM latency</strong> queue for a fixed number of SIMT core clock cycles. Each DRAM clock cycle, the DRAM channel can pop memory request from the <strong>DRAM latency</strong> queue to be serviced by off-chip DRAM, and push one serviced memory request into the <strong>DRAM-&gt;L2</strong> queue.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> memory_partition_unit::dram_cycle() </div><div class="line">&#123; </div><div class="line">    <span class="comment">// pop completed memory request from dram and push it to dram-to-L2 queue </span></div><div class="line">    <span class="comment">// of the original sub partition </span></div><div class="line">    mem_fetch* mf_return = m_dram-&gt;return_queue_top();</div><div class="line">    <span class="keyword">if</span> (mf_return) &#123;</div><div class="line">        <span class="keyword">unsigned</span> dest_global_spid = mf_return-&gt;get_sub_partition_id(); </div><div class="line">        <span class="keyword">int</span> dest_spid = global_sub_partition_id_to_local_id(dest_global_spid); </div><div class="line">        assert(m_sub_partition[dest_spid]-&gt;get_id() == dest_global_spid); </div><div class="line">        <span class="keyword">if</span> (!m_sub_partition[dest_spid]-&gt;dram_L2_queue_full()) &#123;</div><div class="line">            <span class="keyword">if</span>( mf_return-&gt;get_access_type() == L1_WRBK_ACC ) &#123;</div><div class="line">                m_sub_partition[dest_spid]-&gt;set_done(mf_return); </div><div class="line">                <span class="keyword">delete</span> mf_return;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                m_sub_partition[dest_spid]-&gt;dram_L2_queue_push(mf_return);</div><div class="line">                mf_return-&gt;set_status(IN_PARTITION_DRAM_TO_L2_QUEUE,gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">                m_arbitration_metadata.return_credit(dest_spid); </div><div class="line">                MEMPART_DPRINTF(<span class="string">"mem_fetch request %p return from dram to sub partition %d\n"</span>, mf_return, dest_spid); </div><div class="line">            &#125;</div><div class="line">            m_dram-&gt;return_queue_pop(); </div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        m_dram-&gt;return_queue_pop(); </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    m_dram-&gt;cycle(); </div><div class="line">    m_dram-&gt;dram_log(SAMPLELOG);   </div><div class="line"></div><div class="line">    <span class="keyword">if</span>( !m_dram-&gt;full() ) &#123;</div><div class="line">        <span class="comment">// L2-&gt;DRAM queue to DRAM latency queue</span></div><div class="line">        <span class="comment">// Arbitrate among multiple L2 subpartitions </span></div><div class="line">        <span class="keyword">int</span> last_issued_partition = m_arbitration_metadata.last_borrower(); </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> p = <span class="number">0</span>; p &lt; m_config-&gt;m_n_sub_partition_per_memory_channel; p++) &#123;</div><div class="line">            <span class="keyword">int</span> spid = (p + last_issued_partition + <span class="number">1</span>) % m_config-&gt;m_n_sub_partition_per_memory_channel; </div><div class="line">            <span class="keyword">if</span> (!m_sub_partition[spid]-&gt;L2_dram_queue_empty() &amp;&amp; can_issue_to_dram(spid)) &#123;</div><div class="line">                mem_fetch *mf = m_sub_partition[spid]-&gt;L2_dram_queue_top();</div><div class="line">                m_sub_partition[spid]-&gt;L2_dram_queue_pop();</div><div class="line">                MEMPART_DPRINTF(<span class="string">"Issue mem_fetch request %p from sub partition %d to dram\n"</span>, mf, spid); </div><div class="line">                <span class="keyword">dram_delay_t</span> d;</div><div class="line">                d.req = mf;</div><div class="line">                d.ready_cycle = gpu_sim_cycle+gpu_tot_sim_cycle + m_config-&gt;dram_latency;</div><div class="line">                m_dram_latency_queue.push_back(d);</div><div class="line">                mf-&gt;set_status(IN_PARTITION_DRAM_LATENCY_QUEUE,gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">                m_arbitration_metadata.borrow_credit(spid); </div><div class="line">                <span class="keyword">break</span>;  <span class="comment">// the DRAM should only accept one request per cycle </span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// DRAM latency queue</span></div><div class="line">    <span class="keyword">if</span>( !m_dram_latency_queue.empty() &amp;&amp; ( (gpu_sim_cycle+gpu_tot_sim_cycle) &gt;= m_dram_latency_queue.front().ready_cycle ) &amp;&amp; !m_dram-&gt;full() ) &#123;</div><div class="line">        mem_fetch* mf = m_dram_latency_queue.front().req;</div><div class="line">        m_dram_latency_queue.pop_front();</div><div class="line">        m_dram-&gt;push(mf);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Other than moving mf between queues, <strong><em>m_dram-&gt;cycle()</em></strong> is executed to model the DRAM read/write opertaion. The official documents:<br>The DRAM timing model is implemented in the files dram.h and dram.cc. The timing model also includes an implementation of a FIFO scheduler. The more complicated FRFCFS scheduler is located in dram_sched.h and dram_sched.cc.<br>The function <strong><em>dram_t::cycle()</em></strong> represents a DRAM cycle. In each cycle, the DRAM pops a request from the request queue then calls the scheduler function to allow the scheduler to select a request to be serviced based on the scheduling policy. Before the requests are sent to the scheduler, they wait in the DRAM latency queue for a fixed number of SIMT core cycles. This functionality is also implemented inside <strong><em>dram_t::cycle()</em></strong>.<br>The DRAM timing model then checks if any bank is ready to issue a new request based on the different timing constraints specified in the configuration file. Those constraints are represented in the DRAM model by variables similar to this one<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> CCDc; <span class="comment">//Column to Column Delay</span></div></pre></td></tr></table></figure></p>
<p>Those variables are decremented at the end of each cycle. An action is only taken when all of its constraint variables have reached zero. Each taken action resets a set of constraint variables to their original configured values. For example, when a column is activated, the variable <strong><em>CCDc</em></strong> is reset to its original configured value, then decremented by one every cycle. We cannot scheduler a new column until this variable reaches zero. The Macro DEC2ZERO decrements a variable until it reaches zero, and then it keeps it at zero until another action resets it.</p>
<h3 id="4th-Part-Moving-memory-request-from-NoC-to-memory-partition-amp-L2-Operation"><a href="#4th-Part-Moving-memory-request-from-NoC-to-memory-partition-amp-L2-Operation" class="headerlink" title="4th Part - Moving memory request from NoC to memory partition &amp; L2 Operation"></a>4th Part - Moving memory request from NoC to memory partition &amp; L2 Operation</h3><p>Other than popping the memory request from NoC into <strong><em>m_memory_sub_partition[i]</em></strong>, the most important statement in this code is <strong><em>m_memory_sub_partition[i]-&gt;cache_cycle(…)</em></strong> which advances an L2 cycle.<br>The official doc in “Memory Partition Connections and Traffic Flow” can explain this memory partition cycle:<br>The memory request packets enter the Memory Partition from the interconnect via the <strong>ICNT-&gt;L2</strong> queue. Non-texture accesses are directed through the Raster Operation Pipeline(<strong>ROP</strong>) queue to model a minimum pipeline latency. The L2 cache bank pops one request per L2 clock cycle from the <strong>ICNT-&gt;L2</strong> queue for servicing. Any memory requests for the off-chip DRAM generated by the L2 are pushed into the <strong>L2-DRAM</strong> queue. If the L2 cache is disabled, packets are popped from the <strong>ICNT-&gt;L2</strong> and pushed directly into the <strong>L2-DRAM</strong> queue, still at L2 clock frequency. Fill requests returning from off-chip DRAM are popped from <strong>DRAM-&gt;L2</strong> queue and consumed by the L2 cache bank. Read replies from the L2 to the SIMT core are pushed through the <strong>L2-&gt;ICNT</strong> queue.<br>So the function  <strong><em>m_memory_sub_partition[i]-&gt;cache_cycle(…)</em></strong> implements:</p>
<ul>
<li>Pushing the mf(mem_fetch) from L2 cache bank.</li>
<li>Poping the mf from <strong>DRAM-&gt;L2</strong> queue and filling the L2 cache.</li>
<li>Pushing the missed mf into the <strong>L2-&gt;DRAM</strong> queue</li>
<li>Popping the mf from the <strong>ICNT-&gt;L2</strong> queue, and pushing it into <strong>L2-&gt;ICN</strong> queue if hitted, or <strong>L2-&gt;DRAM</strong> queue otherwise.</li>
<li>Pushing the mf from <strong>ROP</strong> queue to <strong>ICNT-&gt;L2</strong> queue.</li>
</ul>
<h3 id="5th-part-One-Cycle-in-NoC"><a href="#5th-part-One-Cycle-in-NoC" class="headerlink" title="5th part - One Cycle in NoC"></a>5th part - One Cycle in NoC</h3><p>NoC simulation is done using a modified booksim simulator.  Skip this part since it’s not our focus.</p>
<h3 id="6th-part-Shader-core-pipeline-Stages"><a href="#6th-part-Shader-core-pipeline-Stages" class="headerlink" title="6th part - Shader core pipeline Stages"></a>6th part - Shader core pipeline Stages</h3><p>If there is still some Thread Array(CTA) left, then invoke <strong><em>m_cluster[i]-&gt;core_cycle()</em></strong> to advance a shader core cluster cycle. Inside the cluster cycle, each shader core is iterated and <strong><em>m_core[\</em>it]-&gt;cycle()*</strong> is called.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> shader_core_ctx::cycle()</div><div class="line">&#123;</div><div class="line">    m_stats-&gt;shader_cycles[m_sid]++;</div><div class="line">    writeback();</div><div class="line">    execute();</div><div class="line">    read_operands();</div><div class="line">    issue();</div><div class="line">    decode();</div><div class="line">    fetch();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note that the functions for different pipeline stages are reversely called in <strong><em>shader_core_ctx::cycle()</em></strong><br>to mimic the pipeline operations in a shader core (this preserves the initial condition in the pipeline).  We discuss these functions in the original order as they appear in a real machine.</p>
<h4 id="Fetch-Stage"><a href="#Fetch-Stage" class="headerlink" title="Fetch Stage"></a>Fetch Stage</h4><h5 id="I-Cache"><a href="#I-Cache" class="headerlink" title="I-Cache"></a>I-Cache</h5><p><strong><em>read_only_cache \</em>m_L1I*</strong> is mameber of <strong><em>shader_core_ctx</em></strong>, it is initialized in the constructor:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">shader_core_ctx::shader_core_ctx(...)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> ( m_config-&gt;gpgpu_perfect_mem ) &#123;</div><div class="line">        m_icnt = <span class="keyword">new</span> perfect_memory_interface(<span class="keyword">this</span>,cluster);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        m_icnt = <span class="keyword">new</span> shader_memory_interface(<span class="keyword">this</span>,cluster);</div><div class="line">    &#125;</div><div class="line">    m_mem_fetch_allocator = <span class="keyword">new</span> shader_core_mem_fetch_allocator(shader_id,tpc_id,mem_config);</div><div class="line">    </div><div class="line">    <span class="comment">// fetch</span></div><div class="line">    m_last_warp_fetched = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> STRSIZE 1024</span></div><div class="line">    <span class="keyword">char</span> name[STRSIZE];</div><div class="line">    <span class="built_in">snprintf</span>(name, STRSIZE, <span class="string">"L1I_%03d"</span>, m_sid);</div><div class="line">    m_L1I = <span class="keyword">new</span> read_only_cache( name,m_config-&gt;m_L1I_config,m_sid,get_shader_instruction_cache_id(),m_icnt,IN_L1I_MISS_QUEUE);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>I-Cache is a read-only, non-blocking, set-associative cache that can model both FIFO and LRU replacement policies with on-miss or on-fill allocation policies.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">read_only_cache::access( new_addr_type addr,</div><div class="line">                         mem_fetch *mf,</div><div class="line">                         unsigned time,</div><div class="line">                         std::list&lt;cache_event&gt; &amp;events )</div><div class="line">&#123;</div><div class="line">    assert( mf-&gt;get_data_size() &lt;= m_config.get_line_sz());</div><div class="line">    assert(m_config.m_write_policy == READ_ONLY);</div><div class="line">    assert(!mf-&gt;get_is_write());</div><div class="line">    new_addr_type block_addr = m_config.block_addr(addr);</div><div class="line">    unsigned cache_index = (unsigned)-1;</div><div class="line">    enum cache_request_status status = m_tag_array-&gt;probe(block_addr,cache_index);</div><div class="line">    enum cache_request_status cache_status = RESERVATION_FAIL;</div><div class="line"></div><div class="line">    if ( status == HIT ) &#123;</div><div class="line">        cache_status = m_tag_array-&gt;access(block_addr,time,cache_index); // update LRU state</div><div class="line">    &#125;else if ( status != RESERVATION_FAIL ) &#123;</div><div class="line">        if(!miss_queue_full(0))&#123;</div><div class="line">            bool do_miss=false;</div><div class="line">            send_read_request(addr, block_addr, cache_index, mf, time, do_miss, events, true, false);</div><div class="line">            if(do_miss)</div><div class="line">                cache_status = MISS;</div><div class="line">            else</div><div class="line">                cache_status = RESERVATION_FAIL;</div><div class="line">        &#125;else&#123;</div><div class="line">            cache_status = RESERVATION_FAIL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_stats.inc_stats(mf-&gt;get_access_type(), m_stats.select_stats_status(status, cache_status));</div><div class="line">    return cache_status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>status = m_tag_array-&gt;probe(block_addr,cache_index);</code> compares the tag between m_tag of some line and the input <strong><em>block_addr</em></strong>.<br>and returns the status of cache access. If status is HIT, updates <strong><em>m_last_access_time</em></strong> in <strong><em>m_tag_array-&gt;access(…)</em></strong>. If the status is MISS, <strong><em>send_read_request(…)</em></strong> pushes the mf to its <strong><em>m_miss_queue</em></strong> to send read request to lower level of memory.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/// Sends next request to lower level of memory</div><div class="line">void baseline_cache::cycle()&#123;</div><div class="line">    if ( !m_miss_queue.empty() ) &#123;</div><div class="line">        mem_fetch *mf = m_miss_queue.front();</div><div class="line">        if ( !m_memport-&gt;full(mf-&gt;size(),mf-&gt;get_is_write()) ) &#123;</div><div class="line">            m_miss_queue.pop_front();</div><div class="line">            m_memport-&gt;push(mf);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    bool data_port_busy = !m_bandwidth_management.data_port_free(); </div><div class="line">    bool fill_port_busy = !m_bandwidth_management.fill_port_free(); </div><div class="line">    m_stats.sample_cache_port_utility(data_port_busy, fill_port_busy); </div><div class="line">    m_bandwidth_management.replenish_port_bandwidth(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This code simply sends next memory request to lower level of memory by pushing the cache misses(<strong><em>mem_fetch </em>mf = m_miss_queue.front()*</strong>) to memory port.  </p>
<h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">void shader_core_ctx::fetch()</div><div class="line">&#123;</div><div class="line">    if( !m_inst_fetch_buffer.m_valid ) &#123;</div><div class="line">        // find an active warp with space in instruction buffer that is not already waiting on a cache miss</div><div class="line">        // and get next 1-2 instructions from i-cache...</div><div class="line">        for( unsigned i=0; i &lt; m_config-&gt;max_warps_per_shader; i++ ) &#123;</div><div class="line">            unsigned warp_id = (m_last_warp_fetched+1+i) % m_config-&gt;max_warps_per_shader;</div><div class="line"></div><div class="line">            // this code checks if this warp has finished executing and can be reclaimed</div><div class="line">            if( m_warp[warp_id].hardware_done() &amp;&amp; !m_scoreboard-&gt;pendingWrites(warp_id) &amp;&amp; !m_warp[warp_id].done_exit() ) &#123;</div><div class="line">                bool did_exit=false;</div><div class="line">                for( unsigned t=0; t&lt;m_config-&gt;warp_size;t++) &#123;</div><div class="line">                    unsigned tid=warp_id*m_config-&gt;warp_size+t;</div><div class="line">                    if( m_threadState[tid].m_active == true ) &#123;</div><div class="line">                        m_threadState[tid].m_active = false; </div><div class="line">                        unsigned cta_id = m_warp[warp_id].get_cta_id();</div><div class="line">                        register_cta_thread_exit(cta_id);</div><div class="line">                        m_not_completed -= 1;</div><div class="line">                        m_active_threads.reset(tid);</div><div class="line">                        assert( m_thread[tid]!= NULL );</div><div class="line">                        did_exit=true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if( did_exit ) </div><div class="line">                    m_warp[warp_id].set_done_exit();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // this code fetches instructions from the i-cache or generates memory requests</div><div class="line">            if( !m_warp[warp_id].functional_done() &amp;&amp; !m_warp[warp_id].imiss_pending() &amp;&amp; m_warp[warp_id].ibuffer_empty() ) &#123;</div><div class="line">                address_type pc  = m_warp[warp_id].get_pc();</div><div class="line">                address_type ppc = pc + PROGRAM_MEM_START;</div><div class="line">                unsigned nbytes=16; </div><div class="line">                unsigned offset_in_block = pc &amp; (m_config-&gt;m_L1I_config.get_line_sz()-1);</div><div class="line">                if( (offset_in_block+nbytes) &gt; m_config-&gt;m_L1I_config.get_line_sz() )</div><div class="line">                    nbytes = (m_config-&gt;m_L1I_config.get_line_sz()-offset_in_block);</div><div class="line"></div><div class="line">                // TODO: replace with use of allocator</div><div class="line">                // mem_fetch *mf = m_mem_fetch_allocator-&gt;alloc()</div><div class="line">                mem_access_t acc(INST_ACC_R,ppc,nbytes,false);</div><div class="line">                mem_fetch *mf = new mem_fetch(acc,</div><div class="line">                                              NULL/*we don&apos;t have an instruction yet*/,</div><div class="line">                                              READ_PACKET_SIZE,</div><div class="line">                                              warp_id,</div><div class="line">                                              m_sid,</div><div class="line">                                              m_tpc,</div><div class="line">                                              m_memory_config );</div><div class="line">                std::list&lt;cache_event&gt; events;</div><div class="line">                enum cache_request_status status = m_L1I-&gt;access( (new_addr_type)ppc, mf, gpu_sim_cycle+gpu_tot_sim_cycle,events);</div><div class="line">                if( status == MISS ) &#123;</div><div class="line">                    m_last_warp_fetched=warp_id;</div><div class="line">                    m_warp[warp_id].set_imiss_pending();</div><div class="line">                    m_warp[warp_id].set_last_fetch(gpu_sim_cycle);</div><div class="line">                &#125; else if( status == HIT ) &#123;</div><div class="line">                    m_last_warp_fetched=warp_id;</div><div class="line">                    m_inst_fetch_buffer = ifetch_buffer_t(pc,nbytes,warp_id);</div><div class="line">                    m_warp[warp_id].set_last_fetch(gpu_sim_cycle);</div><div class="line">                    delete mf;</div><div class="line">                &#125; else &#123;</div><div class="line">                    m_last_warp_fetched=warp_id;</div><div class="line">                    assert( status == RESERVATION_FAIL );</div><div class="line">                    delete mf;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_L1I-&gt;cycle();</div><div class="line"></div><div class="line">    if( m_L1I-&gt;access_ready() ) &#123;</div><div class="line">        mem_fetch *mf = m_L1I-&gt;next_access();</div><div class="line">        m_warp[mf-&gt;get_wid()].clear_imiss_pending();</div><div class="line">        delete mf;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The <strong><em>shader_core_ctx::m_inst_fetch_buffer</em></strong> variable acts as a pipeline register between the fetch (instruction cache access) and the decode stage. The statement <strong><em>if(!m_inst_fetch_buffer.m_valid)</em></strong> just checks if <strong><em>m_inst_fetch_buffer</em></strong> is free of valid instructions(if the decode stage does not stall, <strong><em>m_inst_fetch_buffer</em></strong> will be freed by setting <strong><em>m_valid</em></strong> to false), then enters an outer for loop to iterate through every warp running on the shader.<br>Inside the outer for loop, <strong><em>if(m_warp[warp_id].hardware_done() &amp;&amp; !m_scoreboard-&gt;pendingWrites(warp_id) &amp;&amp; !m_warp[warp_id].done_exit())</em></strong> checks the current warp being iterated. If the current warp is finished, it will be reclaimed(Enters an inner for loop to iterate every thread in it and does some cleanup work for each active thread).<br><strong><em>if(!m_warp[warp_id].functional_done() &amp;&amp; !m_warp[warp_id].imiss_pending() &amp;&amp; m_warp[warp_id].ibuffer_empty())</em></strong>, mainly checks if there are no valid instructions already stored in the entry that corresponds the currently checked warp. If the condition is satisfied, then fatch the instructions or generate memory requests for current warp.<br>To fetch an instruction, first get relevant information such as the PC/PPC address and the block offset of the instruction to be fetched. Then create a memory fetch(mf) object with the relevant information, and use the mf object to access the I-cache.<br>There are three return status for accessing the I-cache. </p>
<ul>
<li><strong>HIT</strong>: create a new <strong><em>ifetch_buffer_t</em></strong> object and copy it to <strong><em>m_inst_fetch_buffer</em></strong>, which will be accessed by decode stage in the next cycle. Essentially, <strong><em>m_inst_fetch_buffer</em></strong> associates an instrtuction in <strong><em>m_warp[]</em></strong> by keeping track of the <strong><em>address_type m_pc</em></strong> and <strong><em>unsigned m_warp_id</em></strong>, which can be used by the decode stages to index <strong><em>m_warp[]</em></strong> for the corresponding instruction).</li>
<li><strong>RESERVATION_FAIL</strong>: simply remember <strong><em>m_last_warp_fetched=warp_id</em></strong> and then delete the mf.</li>
<li><strong>MISS</strong>: Set the <strong><em>m_imiss_pending</em></strong> to true.</li>
</ul>
<p>Next, <strong><em>m-L1I-&gt;cycle()</em></strong> is called to sends memory request to lower level of memory.<br>At last, checks if L1 has ready access, and if so then get next avaliable access, clear the pending miss request and delete mf.</p>
<h4 id="Decode-Stage"><a href="#Decode-Stage" class="headerlink" title="Decode Stage"></a>Decode Stage</h4><p>The decode stage simply checks the <strong><em>shader_core_ctx::m_inst_fetch_buffer</em></strong> and start to store the decoded instructions (current configuration decode up to two instructions per cycle) in the instruction buffer entry (<strong><em>m_ibuffer</em></strong>, an object of <strong><em>shd_warp_t::ibuffer_entry</em></strong>) that corresponds to the warp in the <strong><em>shader_core_ctx::m_inst_fetch_buffer</em></strong>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void shader_core_ctx::decode()</div><div class="line">&#123;</div><div class="line">    if( m_inst_fetch_buffer.m_valid ) &#123;</div><div class="line">        // decode 1 or 2 instructions and place them into ibuffer</div><div class="line">        address_type pc = m_inst_fetch_buffer.m_pc;</div><div class="line">        const warp_inst_t* pI1 = ptx_fetch_inst(pc);</div><div class="line">        m_warp[m_inst_fetch_buffer.m_warp_id].ibuffer_fill(0,pI1);</div><div class="line">        m_warp[m_inst_fetch_buffer.m_warp_id].inc_inst_in_pipeline();</div><div class="line">        if( pI1 ) &#123;</div><div class="line">            m_stats-&gt;m_num_decoded_insn[m_sid]++;</div><div class="line">            if(pI1-&gt;oprnd_type==INT_OP)&#123;</div><div class="line">                m_stats-&gt;m_num_INTdecoded_insn[m_sid]++;</div><div class="line">            &#125;else if(pI1-&gt;oprnd_type==FP_OP) &#123;</div><div class="line">            	m_stats-&gt;m_num_FPdecoded_insn[m_sid]++;</div><div class="line">            &#125;</div><div class="line">           const warp_inst_t* pI2 = ptx_fetch_inst(pc+pI1-&gt;isize);</div><div class="line">           if( pI2 ) &#123;</div><div class="line">               m_warp[m_inst_fetch_buffer.m_warp_id].ibuffer_fill(1,pI2);</div><div class="line">               m_warp[m_inst_fetch_buffer.m_warp_id].inc_inst_in_pipeline();</div><div class="line">               m_stats-&gt;m_num_decoded_insn[m_sid]++;</div><div class="line">               if(pI2-&gt;oprnd_type==INT_OP)&#123;</div><div class="line">                   m_stats-&gt;m_num_INTdecoded_insn[m_sid]++;</div><div class="line">               &#125;else if(pI2-&gt;oprnd_type==FP_OP) &#123;</div><div class="line">            	   m_stats-&gt;m_num_FPdecoded_insn[m_sid]++;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        m_inst_fetch_buffer.m_valid = false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Based on the information(pc, warp id, etc) stored in <strong><em>m_inst_fetch_buffer</em></strong>, the decode stage first executes <code>const warp_inst_t* pI1 = ptx_fetch_inst(pc)</code> to get instructions.<br>Step into the <strong><em>ptx_fetch_inst(pc)</em></strong>, we can find <code>return s_g_pc_to_insn[pc]</code> is finally called. <strong><em>s_g_pc_to_insn</em></strong> is created and maintained by the function <strong><em>function_info::ptx_assemble()</em></strong>, which is invoked by <strong><em>gpgpu_ptx_sim_load_ptx_from_string()</em></strong>. The function <strong><em>gpgpu_ptx_sim_load_ptx_from_string()</em></strong> basically uses Lex/Yacc to parse the PTX code in a PTX file and create symbol table for that PTX file. The function <strong><em>ptx_assemble()</em></strong> is highly related to the PTX parsing, branch instruction detection and divergance analysis.<br>After getting an instruction, the decode stage executes <code>m_warp[m_inst_fetch_buffer.m_warp_id].ibuffer_fill(0,pI1)</code> to fill the instruction(s) into the I-Buffer (the <strong><em>ibuffer_entry m_ibuffer[IBUFFER_SIZE]</em></strong> member of the <strong><em>shd_warp_t</em></strong> class).</p>
<h4 id="Issue-Stage"><a href="#Issue-Stage" class="headerlink" title="Issue Stage"></a>Issue Stage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void shader_core_ctx::issue()&#123;</div><div class="line">    //really is issue;</div><div class="line">    for (unsigned i = 0; i &lt; schedulers.size(); i++) &#123;</div><div class="line">        schedulers[i]-&gt;cycle();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This code simply run a cycle for each scheduler. So we need understand  the structure of the scheduler uint first.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> scheduler_unit &#123; <span class="comment">//this can be copied freely, so can be used in std containers.</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// This is the prioritized warp list that is looped over each cycle to determine</span></div><div class="line">    <span class="comment">// which warp gets to issue.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt; m_next_cycle_prioritized_warps;</div><div class="line">    <span class="comment">// The m_supervised_warps list is all the warps this scheduler is supposed to</span></div><div class="line">    <span class="comment">// arbitrate between.  This is useful in systems where there is more than</span></div><div class="line">    <span class="comment">// one warp scheduler. In a single scheduler system, this is simply all</span></div><div class="line">    <span class="comment">// the warps assigned to this core.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt; m_supervised_warps;</div><div class="line">    <span class="comment">// This is the iterator pointer to the last supervised warp you issued</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt;::const_iterator m_last_supervised_issued;</div><div class="line">    shader_core_stats *m_stats;</div><div class="line">    shader_core_ctx* m_shader;</div><div class="line">    <span class="comment">// these things should become accessors: but would need a bigger rearchitect of how shader_core_ctx interacts with its parts.</span></div><div class="line">    Scoreboard* m_scoreboard; </div><div class="line">    simt_stack** m_simt_stack;</div><div class="line">    <span class="comment">//warp_inst_t** m_pipeline_reg;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">shd_warp_t</span>&gt;* m_warp;</div><div class="line">    register_set* m_sp_out;</div><div class="line">    register_set* m_sfu_out;</div><div class="line">    register_set* m_mem_out;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> m_id;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong><em>scheduler_unit::m_sp_out</em></strong>, <strong><em>scheduler_unit::m_sfu_out</em></strong> and <strong><em>scheduler_unit::m_mem_out</em></strong> serivce as register between the issue and execute stages of SP, SFU and Memory pipeline, repectively.<br>The <strong><em>scheduler_unit</em></strong> is the base class, and there are four schedulers derived from this - <strong><em>lrr_scheduler</em></strong>,  <strong><em>gto_scheduler</em></strong>,  <strong><em>two_level_active_scheduler</em></strong>, <strong><em>swl_scheduler</em></strong>. We just focus on the <strong><em>two_level_active_scheduler</em></strong> which is used in the old version.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> two_level_active_scheduler : <span class="keyword">public</span> scheduler_unit &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">order_warps</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_supervised_warp_id</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ( m_next_cycle_prioritized_warps.size() &lt; m_max_active_warps ) &#123;</div><div class="line">            m_next_cycle_prioritized_warps.push_back( &amp;warp(i) );</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">		    m_pending_warps.push_back(&amp;warp(i));</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">done_adding_supervised_warps</span><span class="params">()</span> </span>&#123;</div><div class="line">        m_last_supervised_issued = m_supervised_warps.begin();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">do_on_warp_issued</span><span class="params">( <span class="keyword">unsigned</span> warp_id,</span></span></div><div class="line">                                    <span class="keyword">unsigned</span> num_issued,</div><div class="line">                                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt;::const_iterator&amp; prioritized_iter );</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">deque</span>&lt; <span class="keyword">shd_warp_t</span>* &gt; m_pending_warps;</div><div class="line">    scheduler_prioritization_type m_inner_level_prioritization;</div><div class="line">    scheduler_prioritization_type m_outer_level_prioritization;</div><div class="line">	<span class="keyword">unsigned</span> m_max_active_warps;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>We can find that the scheduler is created at the constrcution of <strong><em>shader_core_ctx</em></strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">shader_core_ctx::shader_core_ctx(...)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    for (int i = 0; i &lt; m_config-&gt;gpgpu_num_sched_per_core; i++) &#123;</div><div class="line">        switch( scheduler )</div><div class="line">        &#123;</div><div class="line">            ...</div><div class="line">            case CONCRETE_SCHEDULER_TWO_LEVEL_ACTIVE:</div><div class="line">                schedulers.push_back(</div><div class="line">                    new two_level_active_scheduler( m_stats,</div><div class="line">                                                    this,</div><div class="line">                                                    m_scoreboard,</div><div class="line">                                                    m_simt_stack,</div><div class="line">                                                    &amp;m_warp,</div><div class="line">                                                    &amp;m_pipeline_reg[ID_OC_SP],</div><div class="line">                                                    &amp;m_pipeline_reg[ID_OC_SFU],</div><div class="line">                                                    &amp;m_pipeline_reg[ID_OC_MEM],</div><div class="line">                                                    i,</div><div class="line">                                                    config-&gt;gpgpu_scheduler_string</div><div class="line">                                                  )</div><div class="line">                );</div><div class="line">                break;</div><div class="line">            ...</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (unsigned i = 0; i &lt; m_warp.size(); i++) &#123;</div><div class="line">        //distribute i&apos;s evenly though schedulers;</div><div class="line">        schedulers[i%m_config-&gt;gpgpu_num_sched_per_core]-&gt;add_supervised_warp_id(i);</div><div class="line">    &#125;</div><div class="line">    for ( int i = 0; i &lt; m_config-&gt;gpgpu_num_sched_per_core; ++i ) &#123;</div><div class="line">        schedulers[i]-&gt;done_adding_supervised_warps();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The <strong><em>std::vector<shd_warp_t>\</shd_warp_t></em> m_warp*</strong>  member in the <strong><em>scheduler_unit</em></strong> is assgined to <strong><em>m_warp</em></strong> in the <strong><em>shader_core_ctx</em></strong>, and all warps are pushed into the <strong><em>m_next_cycle_prioritized_warps</em></strong>, in the construction.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> two_level_active_scheduler::order_warps()</div><div class="line">&#123;</div><div class="line">    <span class="comment">//Move waiting warps to m_pending_warps</span></div><div class="line">    <span class="keyword">unsigned</span> num_demoted = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt;::iterator iter = m_next_cycle_prioritized_warps.begin();</div><div class="line">            iter != m_next_cycle_prioritized_warps.end(); ) &#123;</div><div class="line">        <span class="keyword">bool</span> waiting = (*iter)-&gt;waiting();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">warp_inst_t</span>* inst = (*iter)-&gt;ibuffer_next_inst();</div><div class="line">            <span class="comment">//Is the instruction waiting on a long operation?</span></div><div class="line">            <span class="keyword">if</span> ( inst &amp;&amp; inst-&gt;in[i] &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;m_scoreboard-&gt;islongop((*iter)-&gt;get_warp_id(), inst-&gt;in[i]))&#123;</div><div class="line">                waiting = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( waiting ) &#123;</div><div class="line">            m_pending_warps.push_back(*iter);</div><div class="line">            iter = m_next_cycle_prioritized_warps.erase(iter);</div><div class="line">            SCHED_DPRINTF( <span class="string">"DEMOTED warp_id=%d, dynamic_warp_id=%d\n"</span>,</div><div class="line">                           (*iter)-&gt;get_warp_id(),</div><div class="line">                           (*iter)-&gt;get_dynamic_warp_id() );</div><div class="line">            ++num_demoted;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++iter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//If there is space in m_next_cycle_prioritized_warps, promote the next m_pending_warps</span></div><div class="line">    <span class="keyword">unsigned</span> num_promoted = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> ( SCHEDULER_PRIORITIZATION_SRR == m_outer_level_prioritization ) &#123;</div><div class="line">        <span class="keyword">while</span> ( m_next_cycle_prioritized_warps.size() &lt; m_max_active_warps ) &#123;</div><div class="line">            m_next_cycle_prioritized_warps.push_back(m_pending_warps.front());</div><div class="line">            m_pending_warps.pop_front();</div><div class="line">            SCHED_DPRINTF( <span class="string">"PROMOTED warp_id=%d, dynamic_warp_id=%d\n"</span>,</div><div class="line">                           (m_next_cycle_prioritized_warps.back())-&gt;get_warp_id(),</div><div class="line">                           (m_next_cycle_prioritized_warps.back())-&gt;get_dynamic_warp_id() );</div><div class="line">            ++num_promoted;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>,</div><div class="line">                 <span class="string">"Unimplemented m_outer_level_prioritization: %d\n"</span>,</div><div class="line">                 m_outer_level_prioritization );</div><div class="line">        <span class="built_in">abort</span>();</div><div class="line">    &#125;</div><div class="line">    assert( num_promoted == num_demoted );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>As the comments say, the schuduler first moves waiting warps(warps that conatin instrcutions that are waiting on a long operation) to <strong><em>m_pending_warps</em></strong>. Then check if there is space in <strong><em>m_next_cycle_prioritized_warps</em></strong>, try to find ready warps in <strong><em>m_pending_warps</em></strong> and move them to <strong><em>m_next_cycle_prioritized_warps</em></strong>.<br>Next, we can step into the <code>schedulers[i]-&gt;cycle()</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> scheduler_unit::cycle()</div><div class="line">&#123;</div><div class="line">    SCHED_DPRINTF( <span class="string">"scheduler_unit::cycle()\n"</span> );</div><div class="line">    <span class="keyword">bool</span> valid_inst = <span class="literal">false</span>;  <span class="comment">// there was one warp with a valid instruction to issue (didn't require flush due to control hazard)</span></div><div class="line">    <span class="keyword">bool</span> ready_inst = <span class="literal">false</span>;  <span class="comment">// of the valid instructions, there was one not waiting for pending register writes</span></div><div class="line">    <span class="keyword">bool</span> issued_inst = <span class="literal">false</span>; <span class="comment">// of these we issued one</span></div><div class="line"></div><div class="line">    order_warps();</div><div class="line">    <span class="keyword">for</span> ( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt;::const_iterator iter = m_next_cycle_prioritized_warps.begin();</div><div class="line">          iter != m_next_cycle_prioritized_warps.end();</div><div class="line">          iter++ ) &#123;</div><div class="line">        <span class="comment">// Don't consider warps that are not yet valid</span></div><div class="line">        <span class="keyword">if</span> ( (*iter) == <span class="literal">NULL</span> || (*iter)-&gt;done_exit() ) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        SCHED_DPRINTF( <span class="string">"Testing (warp_id %u, dynamic_warp_id %u)\n"</span>,</div><div class="line">                       (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );</div><div class="line">        <span class="keyword">unsigned</span> warp_id = (*iter)-&gt;get_warp_id();</div><div class="line">        <span class="keyword">unsigned</span> checked=<span class="number">0</span>;</div><div class="line">        <span class="keyword">unsigned</span> issued=<span class="number">0</span>;</div><div class="line">        <span class="keyword">unsigned</span> max_issue = m_shader-&gt;m_config-&gt;gpgpu_max_insn_issue_per_warp;</div><div class="line">        <span class="keyword">while</span>( !warp(warp_id).waiting() &amp;&amp; !warp(warp_id).ibuffer_empty() &amp;&amp; (checked &lt; max_issue) &amp;&amp; (checked &lt;= issued) &amp;&amp; (issued &lt; max_issue) ) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">warp_inst_t</span> *pI = warp(warp_id).ibuffer_next_inst();</div><div class="line">            <span class="keyword">bool</span> valid = warp(warp_id).ibuffer_next_valid();</div><div class="line">            <span class="keyword">bool</span> warp_inst_issued = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">unsigned</span> pc,rpc;</div><div class="line">            m_simt_stack[warp_id]-&gt;get_pdom_stack_top_info(&amp;pc,&amp;rpc);</div><div class="line">            SCHED_DPRINTF( <span class="string">"Warp (warp_id %u, dynamic_warp_id %u) has valid instruction (%s)\n"</span>,</div><div class="line">                           (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id(),</div><div class="line">                           ptx_get_insn_str( pc).c_str() );</div><div class="line">            <span class="keyword">if</span>( pI ) &#123;</div><div class="line">                assert(valid);</div><div class="line">                <span class="keyword">if</span>( pc != pI-&gt;pc ) &#123;</div><div class="line">                    SCHED_DPRINTF( <span class="string">"Warp (warp_id %u, dynamic_warp_id %u) control hazard instruction flush\n"</span>,</div><div class="line">                                   (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );</div><div class="line">                    <span class="comment">// control hazard</span></div><div class="line">                    warp(warp_id).set_next_pc(pc);</div><div class="line">                    warp(warp_id).ibuffer_flush();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    valid_inst = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">if</span> ( !m_scoreboard-&gt;checkCollision(warp_id, pI) ) &#123;</div><div class="line">                        SCHED_DPRINTF( <span class="string">"Warp (warp_id %u, dynamic_warp_id %u) passes scoreboard\n"</span>,</div><div class="line">                                       (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );</div><div class="line">                        ready_inst = <span class="literal">true</span>;</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">active_mask_t</span> &amp;active_mask = m_simt_stack[warp_id]-&gt;get_active_mask();</div><div class="line">                        assert( warp(warp_id).inst_in_pipeline() );</div><div class="line">                        <span class="keyword">if</span> ( (pI-&gt;op == LOAD_OP) || (pI-&gt;op == STORE_OP) || (pI-&gt;op == MEMORY_BARRIER_OP) ) &#123;</div><div class="line">                            <span class="keyword">if</span>( m_mem_out-&gt;has_free() ) &#123;</div><div class="line">                                m_shader-&gt;issue_warp(*m_mem_out,pI,active_mask,warp_id);</div><div class="line">                                issued++;</div><div class="line">                                issued_inst=<span class="literal">true</span>;</div><div class="line">                                warp_inst_issued = <span class="literal">true</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">bool</span> sp_pipe_avail = m_sp_out-&gt;has_free();</div><div class="line">                            <span class="keyword">bool</span> sfu_pipe_avail = m_sfu_out-&gt;has_free();</div><div class="line">                            <span class="keyword">if</span>( sp_pipe_avail &amp;&amp; (pI-&gt;op != SFU_OP) ) &#123;</div><div class="line">                                <span class="comment">// always prefer SP pipe for operations that can use both SP and SFU pipelines</span></div><div class="line">                                m_shader-&gt;issue_warp(*m_sp_out,pI,active_mask,warp_id);</div><div class="line">                                issued++;</div><div class="line">                                issued_inst=<span class="literal">true</span>;</div><div class="line">                                warp_inst_issued = <span class="literal">true</span>;</div><div class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (pI-&gt;op == SFU_OP) || (pI-&gt;op == ALU_SFU_OP) ) &#123;</div><div class="line">                                <span class="keyword">if</span>( sfu_pipe_avail ) &#123;</div><div class="line">                                    m_shader-&gt;issue_warp(*m_sfu_out,pI,active_mask,warp_id);</div><div class="line">                                    issued++;</div><div class="line">                                    issued_inst=<span class="literal">true</span>;</div><div class="line">                                    warp_inst_issued = <span class="literal">true</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;                         &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        SCHED_DPRINTF( <span class="string">"Warp (warp_id %u, dynamic_warp_id %u) fails scoreboard\n"</span>,</div><div class="line">                                       (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( valid ) &#123;</div><div class="line">               <span class="comment">// this case can happen after a return instruction in diverged warp</span></div><div class="line">               SCHED_DPRINTF( <span class="string">"Warp (warp_id %u, dynamic_warp_id %u) return from diverged warp flush\n"</span>,</div><div class="line">                              (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );</div><div class="line">               warp(warp_id).set_next_pc(pc);</div><div class="line">               warp(warp_id).ibuffer_flush();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(warp_inst_issued) &#123;</div><div class="line">                SCHED_DPRINTF( <span class="string">"Warp (warp_id %u, dynamic_warp_id %u) issued %u instructions\n"</span>,</div><div class="line">                               (*iter)-&gt;get_warp_id(),</div><div class="line">                               (*iter)-&gt;get_dynamic_warp_id(),</div><div class="line">                               issued );</div><div class="line">                do_on_warp_issued( warp_id, issued, iter );</div><div class="line">            &#125;</div><div class="line">            checked++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ( issued ) &#123;</div><div class="line">            <span class="comment">// This might be a bit inefficient, but we need to maintain</span></div><div class="line">            <span class="comment">// two ordered list for proper scheduler execution.</span></div><div class="line">            <span class="comment">// We could remove the need for this loop by associating a</span></div><div class="line">            <span class="comment">// supervised_is index with each entry in the m_next_cycle_prioritized_warps</span></div><div class="line">            <span class="comment">// vector. For now, just run through until you find the right warp_id</span></div><div class="line">            <span class="keyword">for</span> ( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">shd_warp_t</span>* &gt;::const_iterator supervised_iter = m_supervised_warps.begin();</div><div class="line">                  supervised_iter != m_supervised_warps.end();</div><div class="line">                  ++supervised_iter ) &#123;</div><div class="line">                <span class="keyword">if</span> ( *iter == *supervised_iter ) &#123;</div><div class="line">                    m_last_supervised_issued = supervised_iter;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// issue stall statistics:</span></div><div class="line">    <span class="keyword">if</span>( !valid_inst ) </div><div class="line">        m_stats-&gt;shader_cycle_distro[<span class="number">0</span>]++; <span class="comment">// idle or control hazard</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( !ready_inst ) </div><div class="line">        m_stats-&gt;shader_cycle_distro[<span class="number">1</span>]++; <span class="comment">// waiting for RAW hazards (possibly due to memory) </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( !issued_inst ) </div><div class="line">        m_stats-&gt;shader_cycle_distro[<span class="number">2</span>]++; <span class="comment">// pipeline stalled</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Firstly, <strong><em>order_warps()</em></strong> is invoked, and <strong><em>two_level_active_scheduler:: order_warps()</em></strong> is actually called. Then, there is a big for loop and a while loop in the for loop. If the while condition is met, the document can explain the next few codes.<br>For each scheduler unit there is an array of SIMT stacks. Each SIMT stack corresponds to one warp. In the <strong><em>scheduler_unit::cycle()</em></strong>, the top of the stack entry for the SIMT stack of the scheduled warp determines the issued instruction. The program counter of the top of the stack entry is normally consistent with the program counter of the next instruction in the I-Buffer that corresponds to the scheduled warp. Otherwise, in case of control hazard, they will not be matched and the instructions within the I-Buffer are flushed.<br>If there is no control hazard, the flow goes to the else branch, where data hazard is checked by executing <code>if(!m_scoreboard-&gt;checkCollision(warp_id, pI))</code>.<br>If there is no data hazard, then the active mask is computed by <code>const active_mask_t &amp;active_mask = m_simt_stack[warp_id]-&gt;get_active_mask()</code>.<br>After getting the active mask, the flow splits into two branches(<code>if ((pI-&gt;op == LOAD_OP) || (pI-&gt;op == STORE_OP) || (pI-&gt;op == MEMORY_BARRIER_OP))</code>) to handle memory related instructions and non-memory related instruction(else case). The memory related branch issues the instruction by calling <strong><em>m_shader-&gt;issue_warp(…);</em></strong> with the argument <strong><em>\</em>m_mem_out*</strong>, while the non-memory branch issues with <strong><em>\</em>m_sp_out*</strong> or <strong><em>\</em>m_sfu_out*</strong>.<br>The document summarizes the issue operation at a high level:<br>The instruction is issued to its suitable execution pipeline using the function <strong><em>shader_core_ctx::issue_warp()</em></strong>. Within this function, instructions are functionally executed by calling <strong><em>shader_core_ctx::func_exec_inst()</em></strong> and the SIMT stack (<strong><em>m_simt_stack[warp_id]</em></strong>) is updated by calling <strong><em>simt_stack::update()</em></strong>. Also, in this function, the warps are held/released due to barriers by <strong><em>shd_warp_t:: set_membar()</em></strong> and <strong><em>barrier_set_t::warp_reaches_barrier</em></strong>. On the other hand, registers are reserved by <strong><em>Scoreboard::reserveRegisters()</em></strong> to be used later by the scoreboard algorithm. <strong><em>The scheduler_unit::m_sp_out</em></strong>, <strong><em>scheduler_unit::m_sfu_out</em></strong>, <strong><em>scheduler_unit::m_mem_out</em></strong> points to the first pipeline register between the issue stage and the execution stage of SP, SFU and Mem pipeline receptively. That is why they are checked before issuing any instruction to its corresponding pipeline using <strong><em>hader_core_ctx::issue_warp()</em></strong>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> shader_core_ctx::issue_warp( register_set&amp; pipe_reg_set, <span class="keyword">const</span> <span class="keyword">warp_inst_t</span>* next_inst, <span class="keyword">const</span> <span class="keyword">active_mask_t</span> &amp;active_mask, <span class="keyword">unsigned</span> warp_id )</div><div class="line">&#123;</div><div class="line">    The statement `<span class="keyword">warp_inst_t</span>** pipe_reg = pipe_reg_set.get_free();` is first executed to get <span class="built_in">free</span> slots in the <span class="keyword">register</span> sets.From the earlier code we know the pipe_reg_set could actually be scheduler_unit::m_sp_out, scheduler_unit::m_sfu_out or scheduler_unit::m_mem_out ,depending what type of instruction is going to be issued.</div><div class="line">    assert(pipe_reg);</div><div class="line">    </div><div class="line">    m_warp[warp_id].ibuffer_free();</div><div class="line">    assert(next_inst-&gt;valid());</div><div class="line">    **pipe_reg = *next_inst; <span class="comment">// static instruction information</span></div><div class="line">    (*pipe_reg)-&gt;issue( active_mask, warp_id, gpu_tot_sim_cycle + gpu_sim_cycle, m_warp[warp_id].get_dynamic_warp_id() ); <span class="comment">// dynamic instruction information</span></div><div class="line">    m_stats-&gt;shader_cycle_distro[<span class="number">2</span>+(*pipe_reg)-&gt;active_count()]++;</div><div class="line">    func_exec_inst( **pipe_reg );</div><div class="line">    <span class="keyword">if</span>( next_inst-&gt;op == BARRIER_OP )&#123;</div><div class="line">    	m_warp[warp_id].store_info_of_last_inst_at_barrier(*pipe_reg);</div><div class="line">        m_barriers.warp_reaches_barrier(m_warp[warp_id].get_cta_id(),warp_id,<span class="keyword">const_cast</span>&lt;<span class="keyword">warp_inst_t</span>*&gt; (next_inst));</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( next_inst-&gt;op == MEMORY_BARRIER_OP )&#123;</div><div class="line">        m_warp[warp_id].set_membar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    updateSIMTStack(warp_id,*pipe_reg);</div><div class="line">    m_scoreboard-&gt;reserveRegisters(*pipe_reg);</div><div class="line">    m_warp[warp_id].set_next_pc(next_inst-&gt;pc + next_inst-&gt;isize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>warp_inst_t** pipe_reg = pipe_reg_set.get_free();</code> is first executed to get free slots in the register sets.From the earlier code we know the <strong><em>pipe_reg_set</em></strong> could actually be <strong><em>scheduler_unit::m_sp_out</em></strong>, <strong><em>scheduler_unit::m_sfu_out</em></strong> or <strong><em>scheduler_unit::m_mem_out</em></strong> ,depending what type of instruction is going to be issued.<br><code>**pipe_reg = *next_inst</code> retrieves the next instruction to be issued for execution.<br><code>(*pipe_reg)-&gt;issue(...)</code> is executed to store the relevant informantion for the issued instruction into the reister set.<br><code>func_exec_inst( **pipe_reg )</code> is further called and  <strong><em>core_t::execute_warp_inst_t(warp_inst_t &amp;inst, unsigned warpId)</em></strong> in this function will be invoked.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="keyword">core_t</span>::<span class="keyword">execute_warp_inst_t</span>(<span class="keyword">warp_inst_t</span> &amp;inst, <span class="keyword">unsigned</span> warpId)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">unsigned</span> t=<span class="number">0</span>; t &lt; m_warp_size; t++ ) &#123;</div><div class="line">        <span class="keyword">if</span>( inst.active(t) ) &#123;</div><div class="line">            <span class="keyword">if</span>(warpId==(<span class="keyword">unsigned</span> (<span class="number">-1</span>)))</div><div class="line">                warpId = inst.warp_id();</div><div class="line">            <span class="keyword">unsigned</span> tid=m_warp_size*warpId+t;</div><div class="line">            m_thread[tid]-&gt;ptx_exec_inst(inst,t);</div><div class="line">            </div><div class="line">            <span class="comment">//virtual function</span></div><div class="line">            checkExecutionStatusAndUpdate(inst,t,tid);</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>A for loop iterates each thread and calls <strong><em>ptx_exec_inst()</em></strong> to execute the warp instruction. The “Insturction Execution” part of the documents says:<br>After parsing, instructions used for functional execution are represented as a <strong><em>ptx_instruction</em></strong> object contained within a function_info object (see cuda-sim/ptx_ir.{h,cc}). Each scalar thread is represented by a <strong><em>ptx_thread_info</em></strong> object. Executing an instruction (functionally) is mainly accomplished by calling the <strong><em>ptx_thread_info::ptx_exec_inst()</em></strong>.<br>The abstract class <strong><em>core_t has</em></strong> the most basic data structures and procedures required for instruction execution functionally. This class is the base class for the <strong><em>shader_core_ctx</em></strong> and <strong><em>functionalSimCore</em></strong> which are used for performance and pure functional simulation respectively. <strong><em>core_t</em></strong> most important members are objects of types <strong><em>simt_stack</em></strong> and <strong><em>ptx_thread_info</em></strong>, which are used in the functional exectuion to keep track of the warps branch divergence and to handle the threads’ instructions execution.<br>Executing instruction simply starts by initializing scalar threads using the function <strong><em>ptx_sim_init_thread</em></strong> (in cuda-sim.cc), then we execute the scalar threads in warps using the <strong><em>function_info::ptx_exec_inst()</em></strong>. In this version, keeping track of threads as warps is done using a <strong><em>simt_stack</em></strong> object for each warp of scalar threads (this is the assumed model here and other models can be used instead), the <strong><em>simt_stack</em></strong> tells which threads are active and which instruction to execute at each cycle so we can execute the scalar threads in warps.<br>In <strong><em>ptx_thread_info::ptx_exec_inst</em></strong>, is where acutally the instructions get functionally executed. We check the instruction opcode and call the corresponding funciton, the file <strong>opcodes.def</strong> contains the functions used to execute each instruction. Every instruction function takes two parameters of type <strong><em>ptx_instruction</em></strong> and <strong><em>ptx_thread_info</em></strong> which hold the data for the instruction and the thread in execution receptively.<br>Information are communicated back from the execution of <strong><em>ptx_exec_inst</em></strong> to the function that executes the warps through modifying <strong><em>warp_inst_t</em></strong> parameter that is passed to the <strong><em>ptx_exec_inst</em></strong> by reference, so for atomics we indicate that the executed warp instruction is atomic and add a call back to the <strong><em>warp_inst_t</em></strong> and which set the atomic flag, the flag is then checked by the warp execution function in order to do the callbacks which are used to execute the atomics (check <strong><em>functionalCoreSim::executeWarp</em></strong> in cuda-sim.cc).<br>As you might have expected more communication is made in the performance simulation than the pure functional simulation. The pure functional execution with <strong><em>functionalSimCore</em></strong> (in cuda-sim{.h,.cc}) can be checked to get more details on the functional execution.<br>Let’s study <code>void ptx_thread_info::ptx_exec_inst( warp_inst_t &amp;inst, unsigned lane_id)</code> step by step:<br>First,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ptx_instruction *pI = m_func_info-&gt;get_instruction(pc);</div></pre></td></tr></table></figure></p>
<p>is executed to get a <strong><em>ptx_instruction</em></strong> object <strong><em>pI</em></strong>. <strong><em>ptx_instruction</em></strong> inherits the <strong><em>warp_inst_t</em></strong> class and has lots of data members as well as function members to for retrieving relevant information (e.g., operand, opcode, etc.) and properties (e.g.,is predicated, is atomic, has memory load/store, etc.) of the represented instruction.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( pI-&gt;has_pred() ) &#123;</div><div class="line">    <span class="keyword">const</span> operand_info &amp;pred = pI-&gt;get_pred();</div><div class="line">    <span class="keyword">ptx_reg_t</span> pred_value = get_operand_value(pred, pred, PRED_TYPE, <span class="keyword">this</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(pI-&gt;get_pred_mod() == <span class="number">-1</span>) &#123;</div><div class="line">        skip = (pred_value.pred &amp; <span class="number">0x0001</span>) ^ pI-&gt;get_pred_neg(); <span class="comment">//ptxplus inverts the zero flag</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        skip = !pred_lookup(pI-&gt;get_pred_mod(), pred_value.pred &amp; <span class="number">0x000F</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>After obtaining the <strong><em>ptx_instruction</em></strong> object <strong><em>pI</em></strong> from <strong><em>m_instr_mem[]</em></strong> in the <strong><em>m_func_info</em></strong> object (a member in <strong><em>ptx_thread_info</em></strong> with the type of <strong><em>function_info</em></strong>), check if <strong><em>pI</em></strong> is a predicated instruction and if so check if the predication condition is satisfied and update a flag skip accordingly to indicated whether this instruction should be executed or not.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( skip ) &#123;</div><div class="line">    inst.set_not_active(lane_id);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">const</span> ptx_instruction *pI_saved = pI;</div><div class="line">    ptx_instruction *pJ = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span>( pI-&gt;get_opcode() == VOTE_OP ) &#123;</div><div class="line">        pJ = <span class="keyword">new</span> ptx_instruction(*pI);</div><div class="line">        *((<span class="keyword">warp_inst_t</span>*)pJ) = inst; <span class="comment">// copy active mask information</span></div><div class="line">        pI = pJ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span> ( pI-&gt;get_opcode() ) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OP_DEF(OP,FUNC,STR,DST,CLASSIFICATION) case OP: FUNC(pI,this); op_classification = CLASSIFICATION; break;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opcodes.def"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> OP_DEF</span></div><div class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>( <span class="string">"Execution error: Invalid opcode (0x%x)\n"</span>, pI-&gt;get_opcode() ); <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">delete</span> pJ;</div><div class="line">    pI = pI_saved;</div><div class="line">      </div><div class="line">    <span class="comment">// Run exit instruction if exit option included</span></div><div class="line">    <span class="keyword">if</span>(pI-&gt;is_exit())</div><div class="line">        exit_impl(pI,<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>After the predication test then deactivate the thread lane if the <strong><em>skip</em></strong> flag is set otherwise execute the instruction. In the above code the actual instruction execution is emulated in the switch case block, in which a file named <strong>opcodes.def</strong> is included to specify the emulating funciton for each type of instruction.<br>Note that there are many instructions not implemented in the current GPGPU-Sim version.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( (pI-&gt;has_memory_read()  || pI-&gt;has_memory_write()) ) &#123;</div><div class="line">    insn_memaddr = last_eaddr();</div><div class="line">    insn_space = last_space();</div><div class="line">    <span class="keyword">unsigned</span> to_type = pI-&gt;get_type();</div><div class="line">    insn_data_size = datatype2size(to_type);</div><div class="line">    insn_memory_op = pI-&gt;has_memory_read() ? memory_load : memory_store;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The above code checks if the instruction contains memory read or write and if so set some variables for later use.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( pI-&gt;get_opcode() == ATOM_OP ) &#123;</div><div class="line">    insn_memaddr = last_eaddr();</div><div class="line">    insn_space = last_space();</div><div class="line">    inst.add_callback( lane_id, last_callback().function, last_callback().instruction, <span class="keyword">this</span> );</div><div class="line">    <span class="keyword">unsigned</span> to_type = pI-&gt;get_type();</div><div class="line">    insn_data_size = datatype2size(to_type);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The above code checks for atomic instruction and set callback function for handling atomic instructions.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (pI-&gt;get_opcode() == TEX_OP) &#123;</div><div class="line">    inst.set_addr(lane_id, last_eaddr() );</div><div class="line">    assert( inst.space == last_space() );</div><div class="line">    insn_data_size = get_tex_datasize(pI, <span class="keyword">this</span>); <span class="comment">// texture obtain its data granularity from the texture info</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The above code checks texture operation.<br>Back to <strong><em>shader_core_ctx::issue_warp()</em></strong>, after <strong><em>func_exec_inst()</em></strong> is called, the following code is simply executed to handle some special cases(<strong><em>BARRIER_OP</em></strong> and <strong><em>MMEMORY_BARRIER_OP</em></strong>).<br>Finally, updates the SIMT stack, reserve occupied registers by the current instruction in the scoreboard for later data hazard detection and set next pc address for warp.</p>
<h4 id="Read-Operand"><a href="#Read-Operand" class="headerlink" title="Read Operand"></a>Read Operand</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> shader_core_ctx::read_operands()</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The operand collector is modeled as one stage in the main pipeline executed by the function <strong><em>shader_core_ctx::cycle()</em></strong>. This stage is represented by the <strong><em>shader_core_ctx::read_operands()</em></strong> function. Refer to ALU Pipeline for more details about the interfaces of the operand collector.<br>The class <strong><em>opndcoll_rfu_t</em></strong> models the operand collector based register file unit. It contains classes that abstracts the collector unit sets, the arbiter and the dispatch units.<br>The <strong><em>opndcoll_rfu_t::allocate_cu(…)</em></strong> is responsible to allocate <strong><em>warp_inst_t</em></strong> to a free operand collector unit within its assigned sets of operand collectors. Also it adds a read requests for all source operands in their corresponding bank queues in the arbitrator.<br>However, <strong><em>opndcoll_rfu_t::allocate_reads(…)</em></strong> processes read requests that do not have conflicts, in other words, the read requests that are in different register banks and do not go to the same operand collector are popped from the arbitrator queues. This accounts for write request priority over read requests.<br>The function <strong><em>opndcoll_rfu_t::dispatch_ready_cu()</em></strong> dispatches the operand registers of ready operand collectors (with all operands are collected) to the execute stage.<br>The function <strong><em>opndcoll_rfu_t::writeback( const warp_inst_t &amp;inst )</em></strong> is called at the write back stage of the memory pipeline. It is responsible to the allocation of writes.  </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/GPU/" rel="tag"># GPU</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/01/NotesAboutDllAndLib/" rel="next" title="Notes about dll and lib">
                <i class="fa fa-chevron-left"></i> Notes about dll and lib
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/17/UseMsbuild/" rel="prev" title="Use v90(VS2008) to build projects in VS2015 solution">
                Use v90(VS2008) to build projects in VS2015 solution <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kover" />
          <p class="site-author-name" itemprop="name">Kover</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Entry-Function"><span class="nav-number">1.</span> <span class="nav-text">Entry Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Simulating-One-Cycle-in-Performance-Simmulation"><span class="nav-number">2.</span> <span class="nav-text">Simulating One Cycle in Performance Simmulation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#simt-core-cluster"><span class="nav-number">2.1.</span> <span class="nav-text">simt_core_cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-t"><span class="nav-number">2.2.</span> <span class="nav-text">core_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shader-core-ctx"><span class="nav-number">2.3.</span> <span class="nav-text">shader_core_ctx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ldst-unit"><span class="nav-number">2.4.</span> <span class="nav-text">ldst_unit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1st-part-Pushing-memory-request-into-FIFO-and-filling-the-L1-cache"><span class="nav-number">2.5.</span> <span class="nav-text">1st part - Pushing memory request into FIFO and filling the L1 cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2nd-part-Popping-from-Memory-Controller-to-NoC"><span class="nav-number">2.6.</span> <span class="nav-text">2nd part - Popping from Memory Controller to NoC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3rd-part-One-cycle-in-DRAM"><span class="nav-number">2.7.</span> <span class="nav-text">3rd part - One cycle in DRAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4th-Part-Moving-memory-request-from-NoC-to-memory-partition-amp-L2-Operation"><span class="nav-number">2.8.</span> <span class="nav-text">4th Part - Moving memory request from NoC to memory partition & L2 Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5th-part-One-Cycle-in-NoC"><span class="nav-number">2.9.</span> <span class="nav-text">5th part - One Cycle in NoC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6th-part-Shader-core-pipeline-Stages"><span class="nav-number">2.10.</span> <span class="nav-text">6th part - Shader core pipeline Stages</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch-Stage"><span class="nav-number">2.10.1.</span> <span class="nav-text">Fetch Stage</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#I-Cache"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">I-Cache</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch"><span class="nav-number">2.10.2.</span> <span class="nav-text">Fetch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Decode-Stage"><span class="nav-number">2.10.3.</span> <span class="nav-text">Decode Stage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Issue-Stage"><span class="nav-number">2.10.4.</span> <span class="nav-text">Issue Stage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-Operand"><span class="nav-number">2.10.5.</span> <span class="nav-text">Read Operand</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kover</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
