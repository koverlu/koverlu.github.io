<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>GPGPU-sim code reading notes | Kover's loft</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GPGPU-sim code reading notes</h1><a id="logo" href="/.">Kover's loft</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GPGPU-sim code reading notes</h1><div class="post-meta">Oct 14, 2016<span> | </span><span class="category"><a href="/categories/ParallelComputing/">ParallelComputing</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="Entry-Function"><a href="#Entry-Function" class="headerlink" title="Entry Function"></a>Entry Function</h2><p>The entry function in the gpgpu-sim is <strong><em>__cudaRegisterFatBinary()</em></strong>. This function first calls <strong><em>CUctx_st &lowast;context = GPGPUSim_Context()</em></strong>, which calls <strong><em>GPGPUSim_Init()</em></strong>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> CUctx_st* <span class="title">GPGPUSim_Context</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">static</span> CUctx_st *the_context = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span>( the_context == <span class="literal">NULL</span> ) &#123;</div><div class="line">                <span class="number">_</span>cuda_device_id *the_gpu = GPGPUSim_Init();</div><div class="line">                the_context = <span class="keyword">new</span> CUctx_st(the_gpu);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> the_context;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note that <strong><em>the_context</em></strong> is static thus there is only one copy of it and the context creation(<strong><em>new CUctx_st(the_gpu)</em></strong>) and <strong><em>GPGPUSim_Init()</em></strong> are only executed once, no matter how many kernels are launched.<br>The most important member in the <strong><em>_cuda_device_id</em></strong> struct is the class <strong><em>gpgpu_sim &lowast;m_gpgpu</em></strong>. <strong><em>gpgpu_sim</em></strong> defines all important interfaces that <strong><em>GPGPU_SIM</em></strong> provides, such as gpu configuration, statistics collection, simulation control, etc. We can find that <strong><em>GPGPUSim_Init()</em></strong> invokes <strong><em>gpgpu_ptx_sim_init_perf()</em></strong>, which creates and returns a new <strong><em>gpgpu_sim</em></strong> object by calling <strong><em>option_paser_cmdline()</em></strong> to parse the input <strong><em>gpgpusim.config</em></strong> file. The function <strong><em>option_paser_cmdline()</em></strong> futher calls several other functions such as <strong><em>ParseCommandLine()</em></strong> and <strong><em>ParseFile()</em></strong> to do the actual config file parsing.<br>Other than creating a <strong><em>gpgpu_sim</em></strong> object and a corresponding <strong><em>_cuda_device_id</em></strong> from the configuration file, <strong><em>GPGPUSim_Init()</em></strong> also calls the <strong><em>start_sim_thread(1)</em></strong> function:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_sim_thread</span><span class="params">(<span class="keyword">int</span> api)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( g_sim_done ) &#123;</div><div class="line">        g_sim_done = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>( api == <span class="number">1</span> ) &#123;</div><div class="line">           pthread_create(&amp;g_simulation_thread,<span class="literal">NULL</span>,gpgpu_sim_thread_concurrent,<span class="literal">NULL</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">           pthread_create(&amp;g_simulation_thread,<span class="literal">NULL</span>,gpgpu_sim_thread_sequential,<span class="literal">NULL</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Obviously, <strong><em>start_sim_thread(1)</em></strong> will fork a thread to execute the <strong><em>gpgpu_sim_thread_concurrent()</em></strong> function:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">gpgpu_sim_thread_concurrent</span><span class="params">(<span class="keyword">void</span>*)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// concurrent kernel execution simulation thread</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">          <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: *** simulation thread starting and spinning waiting for work ***\n"</span>);</div><div class="line">          fflush(<span class="built_in">stdout</span>);</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">while</span>( g_stream_manager-&gt;empty_protected() &amp;&amp; !g_sim_done )</div><div class="line">            ;</div><div class="line">        <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: ** START simulation thread (detected work) **\n"</span>);</div><div class="line">           g_stream_manager-&gt;print(<span class="built_in">stdout</span>);</div><div class="line">           fflush(<span class="built_in">stdout</span>);</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_lock(&amp;g_sim_lock);</div><div class="line">        g_sim_active = <span class="literal">true</span>;</div><div class="line">        pthread_mutex_unlock(&amp;g_sim_lock);</div><div class="line">        <span class="keyword">bool</span> active = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">bool</span> sim_cycles = <span class="literal">false</span>;</div><div class="line">        g_the_gpu-&gt;init();</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// check if a kernel has completed</span></div><div class="line">            <span class="comment">// launch operation on device if one is pending and can be run</span></div><div class="line"></div><div class="line">            <span class="comment">// Need to break this loop when a kernel completes. This was a</span></div><div class="line">            <span class="comment">// source of non-deterministic behaviour in GPGPU-Sim (bug 147).</span></div><div class="line">            <span class="comment">// If another stream operation is available, g_the_gpu remains active,</span></div><div class="line">            <span class="comment">// causing this loop to not break. If the next operation happens to be</span></div><div class="line">            <span class="comment">// another kernel, the gpu is not re-initialized and the inter-kernel</span></div><div class="line">            <span class="comment">// behaviour may be incorrect. Check that a kernel has finished and</span></div><div class="line">            <span class="comment">// no other kernel is currently running.</span></div><div class="line">            <span class="keyword">if</span>(g_stream_manager-&gt;operation(&amp;sim_cycles) &amp;&amp; !g_the_gpu-&gt;active())</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>( g_the_gpu-&gt;active() ) &#123;</div><div class="line">                g_the_gpu-&gt;cycle();</div><div class="line">                sim_cycles = <span class="literal">true</span>;</div><div class="line">                g_the_gpu-&gt;deadlock_check();</div><div class="line">            &#125;</div><div class="line">            active=g_the_gpu-&gt;active() || !g_stream_manager-&gt;empty_protected();</div><div class="line">        &#125; <span class="keyword">while</span>( active );</div><div class="line">        <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: ** STOP simulation thread (no work) **\n"</span>);</div><div class="line">           fflush(<span class="built_in">stdout</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sim_cycles) &#123;</div><div class="line">            g_the_gpu-&gt;update_stats();</div><div class="line">            print_simulation_time();</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_lock(&amp;g_sim_lock);</div><div class="line">        g_sim_active = <span class="literal">false</span>;</div><div class="line">        pthread_mutex_unlock(&amp;g_sim_lock);</div><div class="line">    &#125; <span class="keyword">while</span>( !g_sim_done );</div><div class="line">    <span class="keyword">if</span>(g_debug_execution &gt;= <span class="number">3</span>) &#123;</div><div class="line">       <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim: *** simulation thread exiting ***\n"</span>);</div><div class="line">       fflush(<span class="built_in">stdout</span>);</div><div class="line">    &#125;</div><div class="line">    sem_post(&amp;g_sim_signal_exit);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note that <strong><em>g_the_gpu</em></strong> is a global variable defined in <strong><em>gpgpusim_entrypoint.cc</em></strong> and is initialized to point to the newly created <strong><em>gpgpu_sim</em></strong> object in <strong><em>gpgpu_ptx_sim_init_perf()</em></strong> .<br>The effect of executing <strong><em>g_the_gpu-&gt;init()</em></strong> is to initialize simulation cycle, control flow, memory access, statistics of various kinds (simulation results), etc.<br>Following the init the simulation gets into a <strong><em>do…while</em></strong> loop.  This is the main loop that simulates the running cuda application cycle by cycle. Each iteration of this loop simulates one cycle (by <strong><em>g_stream_manager-&gt;operation(&amp;sim_cycles)</em></strong> and <strong><em>g_the_gpu-&gt;cycle()</em></strong>) if the <strong><em>g_the_gpu</em></strong> is active.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> stream_manager::operation( <span class="keyword">bool</span> * sim)</div><div class="line">&#123;</div><div class="line">        pthread_mutex_lock(&amp;m_lock);</div><div class="line">        <span class="keyword">bool</span> check=check_finished_kernel();</div><div class="line">        <span class="keyword">if</span>(check) m_gpu-&gt;print_stats();</div><div class="line">        stream_operation op =front();</div><div class="line">        op.do_operation( m_gpu );</div><div class="line">        pthread_mutex_unlock(&amp;m_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><em>stream_manager</em></strong> primarily contains a list of <strong><em>CUstream_st</em></strong> (<strong><em>m_streams</em></strong>), a pointer (<strong><em>m_gpu</em></strong>) to the simulation instance (<strong><em>gpgpu_sim</em></strong>), and some flags such as if the cuda launch is blocking or not.  The CUstream_st  is a struct that contains a list of <strong><em>stream_operation</em></strong> objects (<strong><em>std::list<stream_operation> m_operations</stream_operation></em></strong>) and a few methods to manipulate the <strong><em>stream_operation</em></strong> objects in the list.<br><strong><em>stream_operation</em></strong> essentially keeps track of different types of cuda operations such as kernel launch, memory copy, etc.<br>After <strong><em>stream_operation op</em></strong>  is popped from the list using <strong><em>front()</em></strong>, the statement <strong><em>op.do_operation(m_gpu)</em></strong> is executed.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> stream_operation::do_operation( gpgpu_sim *gpu )</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">switch</span>( m_type ) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">case</span> stream_kernel_launch:</div><div class="line">        <span class="keyword">if</span>( gpu-&gt;can_start_kernel() ) &#123;</div><div class="line">        	gpu-&gt;set_cache_config(m_kernel-&gt;name());</div><div class="line">        	<span class="built_in">printf</span>(<span class="string">"kernel \'%s\' transfer to GPU hardware scheduler\n"</span>, m_kernel-&gt;name().c_str() );</div><div class="line">            <span class="keyword">if</span>( m_sim_mode )</div><div class="line">                gpgpu_cuda_ptx_sim_main_func( *m_kernel );</div><div class="line">            <span class="keyword">else</span></div><div class="line">                gpu-&gt;launch( m_kernel );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">abort</span>();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This function contains a big switch case statement and gets to different branches based on the type of the stream operation. Since we mainly concern about the kernal launch thus we focus on <strong><em>stram_kernal_launch</em></strong> case. Based on which mode(performance simulation mode or purely functional simulation mode) is chosen, there are two paths.<br>We focus on tracing the code for performance simulation, so the second path, <strong><em>gpu-&gt;launch(m_kernel)</em></strong>, is executed. It puts <strong><em>m_kernel</em></strong><br>into a “NULL” or “done” element in the <strong><em>std::vector&lt;kernel_info_t</em>&gt; m_running_kernels*</strong> member in the <strong><em>gpgpu_sim</em></strong> instance. Importantly, putting valid things in the running kernel vector will result in a TRUE return value upon the <strong><em>bool gpgpu_sim::actvie()</em></strong> function invovation.<br>Thus <strong><em>g_the_gpu-&gt;cycle()</em></strong> will be executed for performance simulation after <strong><em>g_stream_manager-&gt;operation(&amp;sim_cycles)</em></strong> when performance simulated mode is selected.</p>
<h2 id="Simulating-One-Cycle-in-Performance-Simmulation"><a href="#Simulating-One-Cycle-in-Performance-Simmulation" class="headerlink" title="Simulating One Cycle in Performance Simmulation"></a>Simulating One Cycle in Performance Simmulation</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> gpgpu_sim::cycle()</div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> clock_mask = next_clock_domain();</div><div class="line">   <span class="comment">//=====1st part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; CORE ) &#123;</div><div class="line">       <span class="comment">// shader core loading (pop from ICNT into core) follows CORE clock</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) </div><div class="line">         m_cluster[i]-&gt;icnt_cycle(); </div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====1st part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====2nd part=====</span></div><div class="line">    <span class="keyword">if</span> (clock_mask &amp; ICNT) &#123;</div><div class="line">        <span class="comment">// pop from memory controller to interconnect</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem_sub_partition;i++) &#123;</div><div class="line">            mem_fetch* mf = m_memory_sub_partition[i]-&gt;top();</div><div class="line">            <span class="keyword">if</span> (mf) &#123;</div><div class="line">                <span class="keyword">unsigned</span> response_size = mf-&gt;get_is_write()?mf-&gt;get_ctrl_size():mf-&gt;size();</div><div class="line">                <span class="keyword">if</span> ( ::icnt_has_buffer( m_shader_config-&gt;mem2device(i), response_size ) ) &#123;</div><div class="line">                    <span class="keyword">if</span> (!mf-&gt;get_is_write()) </div><div class="line">                       mf-&gt;set_return_timestamp(gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">                    mf-&gt;set_status(IN_ICNT_TO_SHADER,gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">                    ::icnt_push( m_shader_config-&gt;mem2device(i), mf-&gt;get_tpc(), mf, response_size );</div><div class="line">                    m_memory_sub_partition[i]-&gt;pop();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    gpu_stall_icnt2sh++;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               m_memory_sub_partition[i]-&gt;pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//=====2nd part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====3rd part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; DRAM) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem;i++)&#123;</div><div class="line">         m_memory_partition_unit[i]-&gt;dram_cycle(); <span class="comment">// Issue the dram command (scheduler + delay model)</span></div><div class="line">         <span class="comment">// Update performance counters for DRAM</span></div><div class="line">         m_memory_partition_unit[i]-&gt;set_dram_power_stats(m_power_stats-&gt;pwr_mem_stat-&gt;n_cmd[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_activity[CURRENT_STAT_IDX][i],</div><div class="line">                        m_power_stats-&gt;pwr_mem_stat-&gt;n_nop[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_act[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_pre[CURRENT_STAT_IDX][i],</div><div class="line">                        m_power_stats-&gt;pwr_mem_stat-&gt;n_rd[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_wr[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_req[CURRENT_STAT_IDX][i]);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====3rd part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====4th part=====</span></div><div class="line">   <span class="comment">// L2 operations follow L2 clock domain</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; L2) &#123;</div><div class="line">       m_power_stats-&gt;pwr_mem_stat-&gt;l2_cache_stats[CURRENT_STAT_IDX].clear();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem_sub_partition;i++) &#123;</div><div class="line">          <span class="comment">//move memory request from interconnect into memory partition (if not backed up)</span></div><div class="line">          <span class="comment">//Note:This needs to be called in DRAM clock domain if there is no L2 cache in the system</span></div><div class="line">          <span class="keyword">if</span> ( m_memory_sub_partition[i]-&gt;full() ) &#123;</div><div class="line">             gpu_stall_dramfull++;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              mem_fetch* mf = (mem_fetch*) icnt_pop( m_shader_config-&gt;mem2device(i) );</div><div class="line">              m_memory_sub_partition[i]-&gt;push( mf, gpu_sim_cycle + gpu_tot_sim_cycle );</div><div class="line">          &#125;</div><div class="line">          m_memory_sub_partition[i]-&gt;cache_cycle(gpu_sim_cycle+gpu_tot_sim_cycle);</div><div class="line">          m_memory_sub_partition[i]-&gt;accumulate_L2cache_stats(m_power_stats-&gt;pwr_mem_stat-&gt;l2_cache_stats[CURRENT_STAT_IDX]);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====4th part end=====</span></div><div class="line"></div><div class="line">   <span class="comment">//=====5th part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; ICNT) &#123;</div><div class="line">      icnt_transfer();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//=====5th part end=====</span></div><div class="line">   </div><div class="line">   <span class="comment">//=====6th part=====</span></div><div class="line">   <span class="keyword">if</span> (clock_mask &amp; CORE) &#123;</div><div class="line">      <span class="comment">// L1 cache + shader core pipeline stages</span></div><div class="line">      m_power_stats-&gt;pwr_mem_stat-&gt;core_cache_stats[CURRENT_STAT_IDX].clear();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) &#123;</div><div class="line">         <span class="keyword">if</span> (m_cluster[i]-&gt;get_not_completed() || get_more_cta_left() ) &#123;</div><div class="line">               m_cluster[i]-&gt;core_cycle();</div><div class="line">               *active_sms+=m_cluster[i]-&gt;get_n_active_sms();</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// Update core icnt/cache stats for GPUWattch</span></div><div class="line">         m_cluster[i]-&gt;get_icnt_stats(m_power_stats-&gt;pwr_mem_stat-&gt;n_simt_to_mem[CURRENT_STAT_IDX][i], m_power_stats-&gt;pwr_mem_stat-&gt;n_mem_to_simt[CURRENT_STAT_IDX][i]);</div><div class="line">         m_cluster[i]-&gt;get_cache_stats(m_power_stats-&gt;pwr_mem_stat-&gt;core_cache_stats[CURRENT_STAT_IDX]);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">float</span> temp=<span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;num_shader();i++)&#123;</div><div class="line">        temp+=m_shader_stats-&gt;m_pipeline_duty_cycle[i];</div><div class="line">      &#125;</div><div class="line">      temp=temp/m_shader_config-&gt;num_shader();</div><div class="line">      *average_pipeline_duty_cycle=((*average_pipeline_duty_cycle)+temp);</div><div class="line">        <span class="comment">//cout&lt;&lt;"Average pipeline duty cycle: "&lt;&lt;*average_pipeline_duty_cycle&lt;&lt;endl;</span></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">if</span>( g_single_step &amp;&amp; ((gpu_sim_cycle+gpu_tot_sim_cycle) &gt;= g_single_step) ) &#123;</div><div class="line">          <span class="keyword">asm</span>(<span class="string">"int $03"</span>);</div><div class="line">      &#125;</div><div class="line">      gpu_sim_cycle++;</div><div class="line">      <span class="keyword">if</span>( g_interactive_debugger_enabled ) </div><div class="line">         gpgpu_debug();</div><div class="line"></div><div class="line">      <span class="comment">// McPAT main cycle (interface with McPAT)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GPGPUSIM_POWER_MODEL</span></div><div class="line">      <span class="keyword">if</span>(m_config.g_power_simulation_enabled)&#123;</div><div class="line">          mcpat_cycle(m_config, getShaderCoreConfig(), m_gpgpusim_wrapper, m_power_stats, m_config.gpu_stat_sample_freq, gpu_tot_sim_cycle, gpu_sim_cycle, gpu_tot_sim_insn, gpu_sim_insn);</div><div class="line">      &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">   <span class="comment">//=====6th part end=====</span></div><div class="line">   </div><div class="line">      issue_block2core();</div><div class="line">      </div><div class="line">      <span class="comment">// Depending on configuration, flush the caches once all of threads are completed.</span></div><div class="line">      <span class="keyword">int</span> all_threads_complete = <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (m_config.gpgpu_flush_l1_cache) &#123;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (m_cluster[i]-&gt;get_not_completed() == <span class="number">0</span>)</div><div class="line">                m_cluster[i]-&gt;cache_flush();</div><div class="line">            <span class="keyword">else</span></div><div class="line">               all_threads_complete = <span class="number">0</span> ;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(m_config.gpgpu_flush_l2_cache)&#123;</div><div class="line">          <span class="keyword">if</span>(!m_config.gpgpu_flush_l1_cache)&#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_shader_config-&gt;n_simt_clusters;i++) &#123;</div><div class="line">                  <span class="keyword">if</span> (m_cluster[i]-&gt;get_not_completed() != <span class="number">0</span>)&#123;</div><div class="line">                      all_threads_complete = <span class="number">0</span> ;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (all_threads_complete &amp;&amp; !m_memory_config-&gt;m_L2_config.disabled() ) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Flushed L2 caches...\n"</span>);</div><div class="line">            <span class="keyword">if</span> (m_memory_config-&gt;m_L2_config.get_num_lines()) &#123;</div><div class="line">               <span class="keyword">int</span> dlc = <span class="number">0</span>;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem;i++) &#123;</div><div class="line">                  dlc = m_memory_sub_partition[i]-&gt;flushL2();</div><div class="line">                  assert (dlc == <span class="number">0</span>); <span class="comment">// need to model actual writes to DRAM here</span></div><div class="line">                  <span class="built_in">printf</span>(<span class="string">"Dirty lines flushed from L2 %d is %d\n"</span>, i, dlc  );</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!(gpu_sim_cycle % m_config.gpu_stat_sample_freq)) &#123;</div><div class="line">         <span class="keyword">time_t</span> days, hrs, minutes, sec;</div><div class="line">         <span class="keyword">time_t</span> curr_time;</div><div class="line">         time(&amp;curr_time);</div><div class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  elapsed_time = MAX(curr_time - g_simulation_starttime, <span class="number">1</span>);</div><div class="line">         <span class="keyword">if</span> ( (elapsed_time - last_liveness_message_time) &gt;= m_config.liveness_message_freq ) &#123;</div><div class="line">            days    = elapsed_time/(<span class="number">3600</span>*<span class="number">24</span>);</div><div class="line">            hrs     = elapsed_time/<span class="number">3600</span> - <span class="number">24</span>*days;</div><div class="line">            minutes = elapsed_time/<span class="number">60</span> - <span class="number">60</span>*(hrs + <span class="number">24</span>*days);</div><div class="line">            sec = elapsed_time - <span class="number">60</span>*(minutes + <span class="number">60</span>*(hrs + <span class="number">24</span>*days));</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"GPGPU-Sim uArch: cycles simulated: %lld  inst.: %lld (ipc=%4.1f) sim_rate=%u (inst/sec) elapsed = %u:%u:%02u:%02u / %s"</span>, </div><div class="line">                   gpu_tot_sim_cycle + gpu_sim_cycle, gpu_tot_sim_insn + gpu_sim_insn, </div><div class="line">                   (<span class="keyword">double</span>)gpu_sim_insn/(<span class="keyword">double</span>)gpu_sim_cycle,</div><div class="line">                   (<span class="keyword">unsigned</span>)((gpu_tot_sim_insn+gpu_sim_insn) / elapsed_time),</div><div class="line">                   (<span class="keyword">unsigned</span>)days,(<span class="keyword">unsigned</span>)hrs,(<span class="keyword">unsigned</span>)minutes,(<span class="keyword">unsigned</span>)sec,</div><div class="line">                   ctime(&amp;curr_time));</div><div class="line">            fflush(<span class="built_in">stdout</span>);</div><div class="line">            last_liveness_message_time = elapsed_time; </div><div class="line">         &#125;</div><div class="line">         visualizer_printstat();</div><div class="line">         m_memory_stats-&gt;memlatstat_lat_pw();</div><div class="line">         <span class="keyword">if</span> (m_config.gpgpu_runtime_stat &amp;&amp; (m_config.gpu_runtime_stat_flag != <span class="number">0</span>) ) &#123;</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_BW_STAT) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;m_memory_config-&gt;m_n_mem;i++) </div><div class="line">                  m_memory_partition_unit[i]-&gt;print_stat(<span class="built_in">stdout</span>);</div><div class="line">               <span class="built_in">printf</span>(<span class="string">"maxmrqlatency = %d \n"</span>, m_memory_stats-&gt;max_mrq_latency);</div><div class="line">               <span class="built_in">printf</span>(<span class="string">"maxmflatency = %d \n"</span>, m_memory_stats-&gt;max_mf_latency);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_SHD_INFO) </div><div class="line">               shader_print_runtime_stat( <span class="built_in">stdout</span> );</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_L1MISS) </div><div class="line">               shader_print_l1_miss_stat( <span class="built_in">stdout</span> );</div><div class="line">            <span class="keyword">if</span> (m_config.gpu_runtime_stat_flag &amp; GPU_RSTAT_SCHED) </div><div class="line">               shader_print_scheduler_stat( <span class="built_in">stdout</span>, <span class="literal">false</span> );</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!(gpu_sim_cycle % <span class="number">20000</span>)) &#123;</div><div class="line">         <span class="comment">// deadlock detection </span></div><div class="line">         <span class="keyword">if</span> (m_config.gpu_deadlock_detect &amp;&amp; gpu_sim_insn == last_gpu_sim_insn) &#123;</div><div class="line">            gpu_deadlock = <span class="literal">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            last_gpu_sim_insn = gpu_sim_insn;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      try_snap_shot(gpu_sim_cycle);</div><div class="line">      spill_log_to_file (<span class="built_in">stdout</span>, <span class="number">0</span>, gpu_sim_cycle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="simt-core-cluster"><a href="#simt-core-cluster" class="headerlink" title="simt_core_cluster"></a>simt_core_cluster</h3><p>Class <strong><em>simt_core_cluster</em></strong> models the SIMT core clusters. This class contains an array of SIMT core objects(the member <strong><em>shader_core_ctx &lowast;&lowast;m_core</em></strong>).<br>The <strong><em>simt_core_cluster::core_cycle()</em></strong> method simply cycles each of the SIMT core in order.<br>The <strong><em>simt_core_cluster::icnt_cycle()</em></strong> method pushes memory requests into the SIMT Core Cluster’s reponse FIFO (the member <strong><em>std::list<mem_fetch> m_response_fifo</mem_fetch></em></strong> in the <strong><em>simt_core_cluster</em></strong> class) from the interconnection network. It also pops the requests from the FIFO and sends them to the appropriate core’s instruction cache(the member <strong><em>read_only_cache &lowast;m_L1</em></strong> in the <strong><em>shader_core_ctx</em></strong>) or LDST unit(the member <strong><em>ldst_unit &lowast;m_ldst_unit</em></strong> in the <strong><em>shader_core_ctx</em></strong>).</p>
<h3 id="core-t"><a href="#core-t" class="headerlink" title="core_t"></a>core_t</h3><p>The <strong><em>core_t</em></strong> class just provides an abstract base class for <strong><em>shader_core_ctx</em></strong>  to inherit. <strong><em>core_t</em></strong> contains basic information such as the kernel information (the member <strong><em>kernel_info_t &lowast;m_kernel</em></strong>), ptx thread information (the member class <strong><em>ptx_thread_info &lowast;&lowast; m_thread</em></strong>), SIMT stack (the member <strong><em>simt_stack  &lowast;&lowast;m_simt_stack</em></strong>) and the current simulation instance (the member <strong><em>gpgpu_sim &lowast;m_gpu</em></strong>).  </p>
<h3 id="shader-core-ctx"><a href="#shader-core-ctx" class="headerlink" title="shader_core_ctx"></a>shader_core_ctx</h3><p>Class <strong><em>shader_core_ctx</em></strong> models the SIMT core. Other than the <strong><em>read_only_cache &lowast;m_L1</em></strong> and <strong><em>ldst_unit &lowast;m_ldst_unit</em></strong> members, the class <strong><em>shader_core_ctx</em></strong> also has other important compoents such as the registers for communication between two pipeline stages(e.g. the member <strong><em>std::vector<register_set> m_pipeline_reg</register_set></em></strong>), the scoreboard(the member <strong><em>Scoreboard &lowast;m_scoreboard</em></strong>), the scheduler(the member <strong><em>std::vector&lt;scheduler_unit</em>&gt; schedulers*</strong>) and the operand collector(the member <strong><em>opndcoll_rfu_t m_operand_collector</em></strong>).  </p>
<h3 id="ldst-unit"><a href="#ldst-unit" class="headerlink" title="ldst_unit"></a>ldst_unit</h3><p>Class <strong><em>ldst_unit</em></strong>,a member in the <strong><em>shader_core_ctx</em></strong>  class, contains various memory related components of a shader core including texture caches, constant caches, data caches.<br>Both the <strong><em>simt_core_cluster</em></strong> and the <strong><em>ldst_unit</em></strong> class (a shader core’s load store unit) defines a member named <strong><em>m_response_fifo</em></strong>, which is actually a list of <strong><em>mem_fetch</em></strong> pointers.<br>Class <strong><em>mem_fetch</em></strong> abstracts memory fetch operations with various relevant information such as the memory access type, source, destination, current status, fetched instruction (if it’s an instruction access), etc. In particular, it has members <strong><em>warp_inst_t m_inst</em></strong> and  <strong><em>mem_access_t m_access</em></strong>.<br>Class <strong><em>mem_access_t</em></strong> class just includes simple members related to a memory access such as the address, write or read, requested size, access type and active mask.<br>Class <strong><em>warp_inst_t</em></strong>  class represents an instruction in a warp and comprises information such as the memory accesses incurred by the instruction (the member <strong><em>std::list<mem_access_t> m_accessq</mem_access_t></em></strong>), active mask(<strong><em>active_mask_t m_warp_active_mask</em></strong>), if atomic, cycle when it’s issued, etc.<br>Class <strong><em>warp_inst_t</em></strong> inherits the class <strong><em>inst_t</em></strong> , which defines basic instruction information such as the opcode (the member <strong><em>op_type op</em></strong>), if load or store, register usage, latency (the member <strong><em>unsigned latency</em></strong>), etc.</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/10/14/GPGPU-0/" data-id="ciu96144u00037coi0vlxvvgh" class="article-share-link">Share</a><div class="tags"></div><div class="post-nav"><a href="/2016/09/01/NotesAboutDllAndLib/" class="next">Notes about dll and lib</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ParallelComputing/">ParallelComputing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sitelog/">sitelog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/14/GPGPU-0/">GPGPU-sim code reading notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/NotesAboutDllAndLib/">Notes about dll and lib</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/31/Welcome/">Welcome to my blog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Kover's loft.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>